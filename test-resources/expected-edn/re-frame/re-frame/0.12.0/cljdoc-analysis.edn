{:group-id "re-frame",
 :artifact-id "re-frame",
 :version "0.12.0",
 :analysis {"clj" ({:name re-frame.cofx,
                    :publics ({:name inject-cofx,
                               :file "re_frame/cofx.cljc",
                               :line 29,
                               :arglists ([id] [id value]),
                               :doc "Given an `id`, and an optional, arbitrary `value`, returns an interceptor\nwhose `:before` adds to the `:coeffects` (map) by calling a pre-registered\n'coeffect handler' identified by the `id`.\n\nThe previous association of a `coeffect handler` with an `id` will have\nhappened via a call to `re-frame.core/reg-cofx` - generally on program startup.\n\nWithin the created interceptor, this 'looked up' `coeffect handler` will\nbe called (within the `:before`) with two arguments:\n  - the current value of `:coeffects`\n  - optionally, the originally supplied arbitrary `value`\n\nThis `coeffect handler` is expected to modify and return its first, `coeffects` argument.\n\nExample Of how `inject-cofx` and `reg-cofx` work together\n---------------------------------------------------------\n\n1. Early in app startup, you register a `coeffect handler` for `:datetime`:\n\n   (re-frame.core/reg-cofx\n     :datetime                        ;; usage  (inject-cofx :datetime)\n     (fn coeffect-handler\n       [coeffect]\n       (assoc coeffect :now (js/Date.))))   ;; modify and return first arg\n\n2. Later, add an interceptor to an -fx event handler, using `inject-cofx`:\n\n   (re-frame.core/reg-event-fx        ;; we are registering an event handler\n      :event-id\n      [ ... (inject-cofx :datetime) ... ]    ;; <-- create an injecting interceptor\n      (fn event-handler\n        [coeffect event]\n        ... in here can access (:now coeffect) to obtain current datetime ... )))\n\nBackground\n----------\n\n`coeffects` are the input resources required by an event handler\nto perform its job. The two most obvious ones are `db` and `event`.\nBut sometimes an event handler might need other resources.\n\nPerhaps an event handler needs a random number or a GUID or the current\ndatetime. Perhaps it needs access to a DataScript database connection.\n\nIf an event handler directly accesses these resources, it stops being\npure and, consequently, it becomes harder to test, etc. So we don't\nwant that.\n\nInstead, the interceptor created by this function is a way to 'inject'\n'necessary resources' into the `:coeffects` (map) subsequently given\nto the event handler at call time.",
                               :type :var}
                              {:name inject-db,
                               :file "re_frame/cofx.cljc",
                               :line 112,
                               :type :var}
                              {:name kind,
                               :file "re_frame/cofx.cljc",
                               :line 11,
                               :type :var}
                              {:name reg-cofx,
                               :file "re_frame/cofx.cljc",
                               :line 14,
                               :arglists ([id handler]),
                               :doc "Register the given coeffect `handler` for the given `id`, for later use\nwithin `inject-cofx`.\n\n`id` is keyword, often namespaced.\n`handler` is a function which takes either one or two arguements, the first of which is\nalways `coeffects` and which returns an updated `coeffects`.\n\nSee the docs for `inject-cofx` for example use.",
                               :type :var})}
                   {:name re-frame.core,
                    :publics ({:name ->interceptor,
                               :file "re_frame/core.cljc",
                               :line 142,
                               :type :var}
                              {:name add-post-event-callback,
                               :file "re_frame/core.cljc",
                               :line 201,
                               :arglists ([f] [id f]),
                               :doc "Registers a function `f` to be called after each event is processed\n `f` will be called with two arguments:\n  - `event`: a vector. The event just processed.\n  - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\n\n This is useful in advanced cases like:\n   - you are implementing a complex bootstrap pipeline\n   - you want to create your own handling infrastructure, with perhaps multiple\n     handlers for the one event, etc.  Hook in here.\n   - libraries providing 'isomorphic javascript' rendering on  Nodejs or Nashorn.\n\n'id' is typically a keyword. Supplied at \"add time\" so it can subsequently\nbe used at \"remove time\" to get rid of the right callback.\n",
                               :type :var}
                              {:name after,
                               :file "re_frame/core.cljc",
                               :line 126,
                               :type :var}
                              {:name assoc-coeffect,
                               :file "re_frame/core.cljc",
                               :line 144,
                               :type :var}
                              {:name assoc-effect,
                               :file "re_frame/core.cljc",
                               :line 146,
                               :type :var}
                              {:name clear-cofx,
                               :file "re_frame/core.cljc",
                               :line 66,
                               :type :var}
                              {:name clear-event,
                               :file "re_frame/core.cljc",
                               :line 116,
                               :type :var}
                              {:name clear-fx,
                               :file "re_frame/core.cljc",
                               :line 61,
                               :type :var}
                              {:name clear-sub,
                               :file "re_frame/core.cljc",
                               :line 48,
                               :type :var}
                              {:name clear-subscription-cache!,
                               :file "re_frame/core.cljc",
                               :line 49,
                               :type :var}
                              {:name console,
                               :file "re_frame/core.cljc",
                               :line 164,
                               :type :var}
                              {:name debug,
                               :file "re_frame/core.cljc",
                               :line 122,
                               :type :var}
                              {:name dispatch,
                               :file "re_frame/core.cljc",
                               :line 40,
                               :type :var}
                              {:name dispatch-sync,
                               :file "re_frame/core.cljc",
                               :line 41,
                               :type :var}
                              {:name enqueue,
                               :file "re_frame/core.cljc",
                               :line 147,
                               :type :var}
                              {:name enrich,
                               :file "re_frame/core.cljc",
                               :line 124,
                               :type :var}
                              {:name get-coeffect,
                               :file "re_frame/core.cljc",
                               :line 143,
                               :type :var}
                              {:name get-effect,
                               :file "re_frame/core.cljc",
                               :line 145,
                               :type :var}
                              {:name inject-cofx,
                               :file "re_frame/core.cljc",
                               :line 65,
                               :type :var}
                              {:name make-restore-fn,
                               :file "re_frame/core.cljc",
                               :line 169,
                               :arglists ([]),
                               :doc "Checkpoints the state of re-frame and returns a function which, when\nlater called, will restore re-frame to that checkpointed state.\n\nCheckpoint includes app-db, all registered handlers and all subscriptions.\n",
                               :type :var}
                              {:name on-changes,
                               :file "re_frame/core.cljc",
                               :line 127,
                               :type :var}
                              {:name path,
                               :file "re_frame/core.cljc",
                               :line 123,
                               :type :var}
                              {:name purge-event-queue,
                               :file "re_frame/core.cljc",
                               :line 194,
                               :arglists ([]),
                               :doc "Remove all events queued for processing\n",
                               :type :var}
                              {:name reg-cofx,
                               :file "re_frame/core.cljc",
                               :line 64,
                               :type :var}
                              {:name reg-event-ctx,
                               :file "re_frame/core.cljc",
                               :line 104,
                               :arglists ([id handler]
                                          [id interceptors handler]),
                               :doc "Register the given event `handler` (function) for the given `id`. Optionally, provide\nan `interceptors` chain.\n`id` is typically a namespaced keyword  (but can be anything)\n`handler` is a function: (context-map event-vector) -> context-map\n\nThis form of registration is almost never used. ",
                               :type :var}
                              {:name reg-event-db,
                               :file "re_frame/core.cljc",
                               :line 71,
                               :arglists ([id handler]
                                          [id interceptors handler]),
                               :doc "Register the given event `handler` (function) for the given `id`. Optionally, provide\nan `interceptors` chain.\n`id` is typically a namespaced keyword  (but can be anything)\n`handler` is a function: (db event) -> db\n`interceptors` is a collection of interceptors. Will be flattened and nils removed.\n`handler` is wrapped in its own interceptor and added to the end of the interceptor\n chain, so that, in the end, only a chain is registered.\n Special effects and coeffects interceptors are added to the front of this\n chain.",
                               :type :var}
                              {:name reg-event-fx,
                               :file "re_frame/core.cljc",
                               :line 87,
                               :arglists ([id handler]
                                          [id interceptors handler]),
                               :doc "Register the given event `handler` (function) for the given `id`. Optionally, provide\nan `interceptors` chain.\n`id` is typically a namespaced keyword  (but can be anything)\n`handler` is a function: (coeffects-map event-vector) -> effects-map\n`interceptors` is a collection of interceptors. Will be flattened and nils removed.\n`handler` is wrapped in its own interceptor and added to the end of the interceptor\n chain, so that, in the end, only a chain is registered.\n Special effects and coeffects interceptors are added to the front of the\n interceptor chain.  These interceptors inject the value of app-db into coeffects,\n and, later, action effects.",
                               :type :var}
                              {:name reg-fx,
                               :file "re_frame/core.cljc",
                               :line 60,
                               :type :var}
                              {:name reg-sub,
                               :file "re_frame/core.cljc",
                               :line 45,
                               :type :var}
                              {:name reg-sub-raw,
                               :file "re_frame/core.cljc",
                               :line 51,
                               :arglists ([query-id handler-fn]),
                               :doc "This is a low level, advanced function.  You should probably be\nusing reg-sub instead.\nDocs in https://github.com/day8/re-frame/blob/master/docs/SubscriptionFlow.md",
                               :type :var}
                              {:name register-handler,
                               :file "re_frame/core.cljc",
                               :line 229,
                               :arglists ([& args]),
                               :type :var}
                              {:name register-sub,
                               :file "re_frame/core.cljc",
                               :line 234,
                               :arglists ([& args]),
                               :type :var}
                              {:name remove-post-event-callback,
                               :file "re_frame/core.cljc",
                               :line 222,
                               :arglists ([id]),
                               :type :var}
                              {:name set-loggers!,
                               :file "re_frame/core.cljc",
                               :line 157,
                               :type :var}
                              {:name subscribe,
                               :file "re_frame/core.cljc",
                               :line 46,
                               :type :var}
                              {:name trim-v,
                               :file "re_frame/core.cljc",
                               :line 125,
                               :type :var})}
                   {:name re-frame.db,
                    :publics ({:name app-db,
                               :file "re_frame/db.cljc",
                               :line 10,
                               :type :var})}
                   {:name re-frame.events,
                    :publics ({:name *handling*,
                               :file "re_frame/events.cljc",
                               :line 51,
                               :dynamic true,
                               :type :var}
                              {:name handle,
                               :file "re_frame/events.cljc",
                               :line 53,
                               :arglists ([event-v]),
                               :doc "Given an event vector `event-v`, look up the associated interceptor chain, and execute it.\n",
                               :type :var}
                              {:name kind,
                               :file "re_frame/events.cljc",
                               :line 11,
                               :type :var}
                              {:name register,
                               :file "re_frame/events.cljc",
                               :line 35,
                               :arglists ([id interceptors]),
                               :doc "Associate the given event `id` with the given collection of `interceptors`.\n\n`interceptors` may contain nested collections and there may be nils\nat any level,so process this structure into a simple, nil-less vector\nbefore registration.\n\nTypically, an `event handler` will be at the end of the chain (wrapped\nin an interceptor).",
                               :type :var})}
                   {:name re-frame.fx,
                    :publics ({:name do-fx,
                               :file "re_frame/fx.cljc",
                               :line 47,
                               :doc "An interceptor whose `:after` actions the contents of `:effects`. As a result,\nthis interceptor is Domino 3.\n\nThis interceptor is silently added (by reg-event-db etc) to the front of\ninterceptor chains for all events.\n\nFor each key in `:effects` (a map), it calls the registered `effects handler`\n(see `reg-fx` for registration of effect handlers).\n\nSo, if `:effects` was:\n    {:dispatch  [:hello 42]\n     :db        {...}\n     :undo      \"set flag\"}\n\nit will call the registered effect handlers for each of the map's keys:\n`:dispatch`, `:undo` and `:db`. When calling each handler, provides the map\nvalue for that key - so in the example above the effect handler for :dispatch\nwill be given one arg `[:hello 42]`.\n\nYou cannot rely on the ordering in which effects are executed.",
                               :type :var}
                              {:name kind,
                               :file "re_frame/fx.cljc",
                               :line 15,
                               :type :var}
                              {:name reg-fx,
                               :file "re_frame/fx.cljc",
                               :line 18,
                               :arglists ([id handler]),
                               :doc "Register the given effect `handler` for the given `id`.\n\n`id` is keyword, often namespaced.\n`handler` is a side-effecting function which takes a single argument and whose return\nvalue is ignored.\n\nExample Use\n-----------\n\nFirst, registration ... associate `:effect2` with a handler.\n\n(reg-fx\n   :effect2\n   (fn [value]\n      ... do something side-effect-y))\n\nThen, later, if an event handler were to return this effects map ...\n\n{...\n :effect2  [1 2]}\n\n ... then the `handler` `fn` we registered previously, using `reg-fx`, will be\n called with an argument of `[1 2]`.",
                               :type :var})}
                   {:name re-frame.interceptor,
                    :publics ({:name ->interceptor,
                               :file "re_frame/interceptor.cljc",
                               :line 17,
                               :arglists ([&
                                           {:as m,
                                            :keys [id before after]}]),
                               :doc "Create an interceptor from named arguments\n",
                               :type :var}
                              {:name assoc-coeffect,
                               :file "re_frame/interceptor.cljc",
                               :line 57,
                               :arglists ([context key value]),
                               :type :var}
                              {:name assoc-effect,
                               :file "re_frame/interceptor.cljc",
                               :line 39,
                               :arglists ([context key value]),
                               :type :var}
                              {:name enqueue,
                               :file "re_frame/interceptor.cljc",
                               :line 112,
                               :arglists ([context interceptors]),
                               :doc "Add a collection of `interceptors` to the end of `context's` execution `:queue`.\nReturns the updated `context`.\n\nIn an advanced case, this function could allow an interceptor to add new\ninterceptors to the `:queue` of a context.",
                               :type :var}
                              {:name execute,
                               :file "re_frame/interceptor.cljc",
                               :line 149,
                               :arglists ([event-v interceptors]),
                               :doc "Executes the given chain (coll) of interceptors.\n\nEach interceptor has this form:\n    {:before  (fn [context] ...)     ;; returns possibly modified context\n     :after   (fn [context] ...)}    ;; `identity` would be a noop\n\nWalks the queue of iterceptors from beginning to end, calling the\n`:before` fn on each, then reverse direction and walk backwards,\ncalling the `:after` fn on each.\n\nThe last interceptor in the chain presumably wraps an event\nhandler fn. So the overall goal of the process is to \"handle\nthe given event\".\n\nThread a `context` through all calls. `context` has this form:\n\n  {:coeffects {:event [:a-query-id :some-param]\n               :db    <original contents of app-db>}\n   :effects   {:db    <new value for app-db>\n               :dispatch  [:an-event-id :param1]}\n   :queue     <a collection of further interceptors>\n   :stack     <a collection of interceptors already walked>}\n\n`context` has `:coeffects` and `:effects` which, if this was a web\nserver, would be somewhat anologous to `request` and `response`\nrespectively.\n\n`coeffects` will contain data like `event` and the initial\nstate of `db` -  the inputs required by the event handler\n(sitting presumably on the end of the chain), while handler-returned\nside effects are put into `:effects` including, but not limited to,\nnew values for `db`.\n\nThe first few interceptors in a chain will likely have `:before`\nfunctions which \"prime\" the `context` by adding the event, and\nthe current state of app-db into `:coeffects`. But interceptors can\nadd whatever they want to `:coeffects` - perhaps the event handler needs\nsome information from localstore, or a random number, or access to\na DataScript connection.\n\nEqually, some interceptors in the chain will have `:after` fn\nwhich can process the side effects accumulated into `:effects`\nincluding but, not limited to, updates to app-db.\n\nThrough both stages (before and after), `context` contains a `:queue`\nof interceptors yet to be processed, and a `:stack` of interceptors\nalready done.  In advanced cases, these values can be modified by the\nfunctions through which the context is threaded.",
                               :type :var}
                              {:name get-coeffect,
                               :file "re_frame/interceptor.cljc",
                               :line 49,
                               :arglists ([context]
                                          [context key]
                                          [context key not-found]),
                               :type :var}
                              {:name get-effect,
                               :file "re_frame/interceptor.cljc",
                               :line 31,
                               :arglists ([context]
                                          [context key]
                                          [context key not-found]),
                               :type :var}
                              {:name interceptor?,
                               :file "re_frame/interceptor.cljc",
                               :line 11,
                               :arglists ([m]),
                               :type :var}
                              {:name mandatory-interceptor-keys,
                               :file "re_frame/interceptor.cljc",
                               :line 9,
                               :type :var}
                              {:name update-coeffect,
                               :file "re_frame/interceptor.cljc",
                               :line 61,
                               :arglists ([context key f & args]),
                               :type :var}
                              {:name update-effect,
                               :file "re_frame/interceptor.cljc",
                               :line 43,
                               :arglists ([context key f & args]),
                               :type :var})}
                   {:name re-frame.interop,
                    :publics ({:name add-on-dispose!,
                               :file "re_frame/interop.clj",
                               :line 60,
                               :arglists ([a-ratom f]),
                               :doc "On JVM Clojure, use an atom to register `f` to be invoked when `dispose!` is\ninvoked with `a-ratom`.",
                               :type :var}
                              {:name after-render,
                               :file "re_frame/interop.clj",
                               :line 35,
                               :type :var}
                              {:name debug-enabled?,
                               :file "re_frame/interop.clj",
                               :line 37,
                               :type :var}
                              {:name deref?,
                               :file "re_frame/interop.clj",
                               :line 45,
                               :arglists ([x]),
                               :type :var}
                              {:name dispose!,
                               :file "re_frame/interop.clj",
                               :line 67,
                               :arglists ([a-ratom]),
                               :doc "On JVM Clojure, invoke all callbacks registered with `add-on-dispose!` for\n`a-ratom`.",
                               :type :var}
                              {:name empty-queue,
                               :file "re_frame/interop.clj",
                               :line 33,
                               :type :var}
                              {:name make-reaction,
                               :file "re_frame/interop.clj",
                               :line 48,
                               :arglists ([f]),
                               :doc "On JVM Clojure, return a `deref`-able thing which invokes the given function\non every `deref`. That is, `make-reaction` here provides precisely none of the\nbenefits of `reagent.ratom/make-reaction` (which only invokes its function if\nthe reactions that the function derefs have changed value). But so long as `f`\nonly depends on other reactions (which also behave themselves), the only\ndifference is one of efficiency. That is, your tests should see no difference\nother than that they do redundant work.",
                               :type :var}
                              {:name next-tick,
                               :file "re_frame/interop.clj",
                               :line 28,
                               :arglists ([f]),
                               :type :var}
                              {:name now,
                               :file "re_frame/interop.clj",
                               :line 83,
                               :arglists ([]),
                               :type :var}
                              {:name ratom,
                               :file "re_frame/interop.clj",
                               :line 39,
                               :arglists ([x]),
                               :type :var}
                              {:name ratom?,
                               :file "re_frame/interop.clj",
                               :line 42,
                               :arglists ([x]),
                               :type :var}
                              {:name reagent-id,
                               :file "re_frame/interop.clj",
                               :line 88,
                               :arglists ([reactive-val]),
                               :doc "Doesn't make sense in a Clojure context currently.\n",
                               :type :var}
                              {:name set-timeout!,
                               :file "re_frame/interop.clj",
                               :line 77,
                               :arglists ([f ms]),
                               :doc "Note that we ignore the `ms` value and just invoke the function, because\nthere isn't often much point firing a timed event in a test.",
                               :type :var})}
                   {:name re-frame.loggers,
                    :publics ({:name console,
                               :file "re_frame/loggers.cljc",
                               :line 37,
                               :arglists ([level & args]),
                               :type :var}
                              {:name get-loggers,
                               :file "re_frame/loggers.cljc",
                               :line 50,
                               :arglists ([]),
                               :doc "Get the current logging functions used by re-frame.\n",
                               :type :var}
                              {:name log,
                               :file "re_frame/loggers.cljc",
                               :line 7,
                               :arglists ([level & args]),
                               :type :var}
                              {:name set-loggers!,
                               :file "re_frame/loggers.cljc",
                               :line 43,
                               :arglists ([new-loggers]),
                               :doc "Change the set (or a subset) of logging functions used by re-frame.\n`new-loggers` should be a map with the same keys as `loggers` (above)",
                               :type :var})}
                   {:doc "In many places, re-frame asks you to associate an `id` (keyword)\nwith a `handler` (function).  This namespace contains the\ncentral registry of such associations.",
                    :name re-frame.registrar,
                    :publics ({:name clear-handlers,
                               :file "re_frame/registrar.cljc",
                               :line 44,
                               :arglists ([] [kind] [kind id]),
                               :type :var}
                              {:name get-handler,
                               :file "re_frame/registrar.cljc",
                               :line 18,
                               :arglists ([kind]
                                          [kind id]
                                          [kind id required?]),
                               :type :var}
                              {:name kind->id->handler,
                               :file "re_frame/registrar.cljc",
                               :line 15,
                               :type :var}
                              {:name kinds,
                               :file "re_frame/registrar.cljc",
                               :line 10,
                               :type :var}
                              {:name register-handler,
                               :file "re_frame/registrar.cljc",
                               :line 35,
                               :arglists ([kind id handler-fn]),
                               :type :var})}
                   {:name re-frame.router,
                    :publics ({:name dispatch,
                               :file "re_frame/router.cljc",
                               :line 233,
                               :arglists ([event]),
                               :doc "Enqueue `event` for processing by event handling machinery.\n\n`event` is a vector of length >= 1. The 1st element identifies the kind of event.\n\nNote: the event handler is not run immediately - it is not run\nsynchronously. It will likely be run 'very soon', although it may be\nadded to the end of a FIFO queue which already contain events.\n\nUsage:\n   (dispatch [:order-pizza {:supreme 2 :meatlovers 1 :veg 1})",
                               :type :var}
                              {:name dispatch-sync,
                               :file "re_frame/router.cljc",
                               :line 251,
                               :arglists ([event-v]),
                               :doc "Synchronously (immediately) process `event`. Do not queue.\n\nGenerally, don't use this. Instead use `dispatch`. It is an error\nto use `dispatch-sync` within an event handler.\n\nUseful when any delay in processing is a problem:\n   1. the `:on-change` handler of a text field where we are expecting fast typing.\n   2  when initialising your app - see 'main' in todomvc examples\n   3. in a unit test where we don't want the action 'later'\n\nUsage:\n   (dispatch-sync [:sing :falsetto 634])",
                               :type :var}
                              {:name event-queue,
                               :file "re_frame/router.cljc",
                               :line 226,
                               :type :var}
                              {:name IEventQueue,
                               :file "re_frame/router.cljc",
                               :line 71,
                               :type :protocol,
                               :members ({:name -add-event,
                                          :arglists ([this event]),
                                          :type :var}
                                         {:name -call-post-event-callbacks,
                                          :arglists ([this event]),
                                          :type :var}
                                         {:name -exception,
                                          :arglists ([this ex]),
                                          :type :var}
                                         {:name -fsm-trigger,
                                          :arglists ([this
                                                      trigger
                                                      arg]),
                                          :type :var}
                                         {:name -pause,
                                          :arglists ([this later-fn]),
                                          :type :var}
                                         {:name -process-1st-event-in-queue,
                                          :arglists ([this]),
                                          :type :var}
                                         {:name -resume,
                                          :arglists ([this]),
                                          :type :var}
                                         {:name -run-next-tick,
                                          :arglists ([this]),
                                          :type :var}
                                         {:name -run-queue,
                                          :arglists ([this]),
                                          :type :var}
                                         {:name add-post-event-callback,
                                          :arglists ([this id callack]),
                                          :type :var}
                                         {:name purge,
                                          :arglists ([this]),
                                          :type :var}
                                         {:name push,
                                          :arglists ([this event]),
                                          :type :var}
                                         {:name remove-post-event-callback,
                                          :arglists ([this f]),
                                          :type :var})}
                              {:name later-fns,
                               :file "re_frame/router.cljc",
                               :line 65,
                               :type :var})}
                   {:doc "contains re-frame supplied, standard interceptors\n",
                    :name re-frame.std-interceptors,
                    :publics ({:name after,
                               :file "re_frame/std_interceptors.cljc",
                               :line 295,
                               :arglists ([f]),
                               :doc "returns an interceptor which runs a given function `f` in the `:after`\nposition, presumably for side effects.\n\n`f` is called with two arguments: the `:effects` value for `:db`\n(or the `coeffect` value of db if no db effect is returned) and the event.\nIts return value is ignored, so `f` can only side-effect.\n\nExamples use can be seen in the /examples/todomvc:\n   - `f` runs schema validation (reporting any errors found).\n   - `f` writes to localstorage.",
                               :type :var}
                              {:name ctx-handler->interceptor,
                               :file "re_frame/std_interceptors.cljc",
                               :line 156,
                               :arglists ([handler-fn]),
                               :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-ctx`.\nThese advanced handlers take one argument: `context` and they return a modified `context`.\nExample:\n\n    (fn [context]\n       (enqueue context [more interceptors]))",
                               :type :var}
                              {:name db-handler->interceptor,
                               :file "re_frame/std_interceptors.cljc",
                               :line 93,
                               :arglists ([handler-fn]),
                               :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-db`.\n\nThese handlers take two arguments;  `db` and `event`, and they return `db`.\n\n    (fn [db event]\n       ....)\n\nSo, the interceptor wraps the given handler:\n   1. extracts two `:coeffects` keys: db and event\n   2. calls handler-fn\n   3. stores the db result back into context's `:effects`",
                               :type :var}
                              {:name debug,
                               :file "re_frame/std_interceptors.cljc",
                               :line 14,
                               :doc "An interceptor which logs/instruments an event handler's actions to\n`js/console.debug`. See examples/todomvc/src/events.cljs for use.\n\nOutput includes:\n1. the event vector\n2. a `clojure.data/diff` of db, before vs after, which shows\n   the changes caused by the event handler.  You will absolutely have\n   to understand https://clojuredocs.org/clojure.data/diff to\n   understand the output.\n\nYou'd typically include this interceptor after (to the right of) any\npath interceptor.\n\nWarning:  calling clojure.data/diff on large, complex data structures\ncan be slow. So, you won't want this interceptor present in production\ncode. So condition it out like this :\n\n    (re-frame.core/reg-event-db\n       :evt-id\n       [(when ^boolean goog.DEBUG re-frame.core/debug)]  ;; <-- conditional\n       (fn [db v]\n         ...))\n\nTo make this code fragment work, you'll also have to set goog.DEBUG to\nfalse in your production builds - look in `project.clj` of /examples/todomvc.\n",
                               :type :var}
                              {:name enrich,
                               :file "re_frame/std_interceptors.cljc",
                               :line 237,
                               :arglists ([f]),
                               :doc "Interceptor factory which runs the given function `f` in the `after handler`\nposition.  `f` is called with two arguments: `db` and `v`, and is expected to\nreturn a modified `db`.\n\nUnlike the `after` interceptor which is only about side effects, `enrich`\nexpects `f` to process and alter the given `db` coeffect in some useful way,\ncontributing to the derived data, flowing vibe.\n\nExample Use:\n------------\n\nImagine that todomvc needed to do duplicate detection - if any two todos had\nthe same text, then highlight their background, and report them via a warning\nat the bottom of the panel.\n\nAlmost any user action (edit text, add new todo, remove a todo) requires a\ncomplete reassessment of duplication errors and warnings. Eg: that edit\njust made might have introduced a new duplicate, or removed one. Same with\nany todo removal. So we need to re-calculate warnings after any CRUD events\nassociated with the todos list.\n\nUnless we are careful, we might end up coding subtly different checks\nfor each kind of CRUD operation.  The duplicates check made after\n'delete todo' event might be subtly different to that done after an\nediting operation. Nice and efficient, but fiddly. A bug generator\napproach.\n\nSo, instead, we create an `f` which recalculates ALL warnings from scratch\nevery time there is ANY change. It will inspect all the todos, and\nreset ALL FLAGS every time (overwriting what was there previously)\nand fully recalculate the list of duplicates (displayed at the bottom?).\n\nhttps://twitter.com/nathanmarz/status/879722740776939520\n\nBy applying `f` in an `:enrich` interceptor, after every CRUD event,\nwe keep the handlers simple and yet we ensure this important step\n(of getting warnings right) is not missed on any change.\n\nWe can test `f` easily - it is a pure function - independently of\nany CRUD operation.\n\nThis brings huge simplicity at the expense of some re-computation\neach time. This may be a very satisfactory trade-off in many cases.",
                               :type :var}
                              {:name fx-handler->interceptor,
                               :file "re_frame/std_interceptors.cljc",
                               :line 125,
                               :arglists ([handler-fn]),
                               :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-fx`.\n\nThese handlers take two arguments;  `coeffects` and `event`, and they return `effects`.\n\n    (fn [coeffects event]\n       {:db ...\n        :dispatch ...})\n\n Wrap handler in an interceptor so it can be added to (the RHS) of a chain:\n   1. extracts `:coeffects`\n   2. call handler-fn giving coeffects\n   3. stores the result back into the `:effects`",
                               :type :var}
                              {:name on-changes,
                               :file "re_frame/std_interceptors.cljc",
                               :line 319,
                               :arglists ([f out-path & in-paths]),
                               :doc "Interceptor factory which acts a bit like `reaction`  (but it flows into\n`db`, rather than out). It observes N paths within `db` and if any of them\ntest not identical? to their previous value  (as a result of a event handler\nbeing run) then it runs `f` to compute a new value, which is then assoc-ed\ninto the given `out-path` within `db`.\n\nUsage:\n\n    (defn my-f\n      [a-val b-val]\n      ... some computation on a and b in here)\n\n    (on-changes my-f [:c]  [:a] [:b])\n\nPut this Interceptor on the right handlers (ones which might change :a or :b).\nIt will:\n   - call `f` each time the value at path [:a] or [:b] changes\n   - call `f` with the values extracted from [:a] [:b]\n   - assoc the return value from `f` into the path  [:c]\n",
                               :type :var}
                              {:name path,
                               :file "re_frame/std_interceptors.cljc",
                               :line 182,
                               :arglists ([& args]),
                               :doc "returns an interceptor whose `:before` substitutes the coeffects `:db` with\na sub-path of `:db`. Within `:after` it grafts the handler's return value\nback into db, at the right path.\n\nSo, its overall action is to make the event handler behave like the function\nyou might give to clojure's `update-in`.\n\nExamples:\n\n    (path :some :path)\n    (path [:some :path])\n    (path [:some :path] :to :here)\n    (path [:some :path] [:to] :here)\n\nExample Use:\n\n    (reg-event-db\n      :event-id\n      (path [:a :b])  ;; used here, in interceptor chain\n      (fn [b v]       ;; 1st arg is now not db. Is the value from path [:a :b] within db\n        ... new-b))   ;; returns a new value for that path (not the entire db)\n\nNotes:\n  1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\n  2. if `:effects` contains no `:db` effect, can't graft a value back in.\n",
                               :type :var}
                              {:name trim-v,
                               :file "re_frame/std_interceptors.cljc",
                               :line 65,
                               :doc "An interceptor which removes the first element of the event vector,\nallowing you to write more aesthetically pleasing event handlers. No\nleading underscore on the event-v!\nYour event handlers will look like this:\n\n    (defn my-handler\n      [db [x y z]]    ;; <-- instead of [_ x y z]\n      ....)",
                               :type :var})}
                   {:name re-frame.subs,
                    :publics ({:name cache-and-return,
                               :file "re_frame/subs.cljc",
                               :line 42,
                               :arglists ([query-v dynv r]),
                               :doc "cache the reaction r\n",
                               :type :var}
                              {:name cache-lookup,
                               :file "re_frame/subs.cljc",
                               :line 65,
                               :arglists ([query-v] [query-v dyn-v]),
                               :type :var}
                              {:name clear-all-handlers!,
                               :file "re_frame/subs.cljc",
                               :line 36,
                               :arglists ([]),
                               :doc "Unregisters all existing subscription handlers\n",
                               :type :var}
                              {:name clear-subscription-cache!,
                               :file "re_frame/subs.cljc",
                               :line 20,
                               :arglists ([]),
                               :doc "Causes all subscriptions to be removed from the cache.\nDoes this by:\n   1. running `on-dispose` on all cached subscriptions\n   2. Each `on-dispose` will perform the removal of themselves.\n\nThis is for development time use. Useful when reloading Figwheel code\nafter a React exception, because React components won't have been\ncleaned up properly. And this, in turn, means the subscriptions within those\ncomponents won't have been cleaned up correctly. So this forces the issue.",
                               :type :var}
                              {:name kind,
                               :file "re_frame/subs.cljc",
                               :line 10,
                               :type :var}
                              {:name map-signals,
                               :file "re_frame/subs.cljc",
                               :line 171,
                               :arglists ([f signals]),
                               :doc "Runs f over signals. Signals may take several\nforms, this function handles all of them.",
                               :type :var}
                              {:name query->reaction,
                               :file "re_frame/subs.cljc",
                               :line 18,
                               :type :var}
                              {:name reg-sub,
                               :file "re_frame/subs.cljc",
                               :line 200,
                               :arglists ([query-id & args]),
                               :doc "For a given `query-id`, register two functions: a `computation` function and an `input signals` function.\n \n During program execution, a call to `subscribe`, such as `(subscribe [:sub-id 3 \"blue\"])`,\n will create a new `:sub-id` node in the Signal Graph. And, at that time, re-frame\n needs to know how to create the node.   By calling `reg-sub`, you are registering \n 'the template' or 'the mechanism' by which nodes in the Signal Graph can be created. \n\n Repeating: calling `reg-sub` does not create a node. It only creates the template\n from which nodes can be created later. \n \n `reg-sub` arguments are:  \n   - a `query-id` (typically a namespaced keyword)\n   - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways) \n   - a function which computes the value of this kind of node \n\n The `computation function` is always the last argument supplied and it is expected to have the signature: \n   `(input-values, query-vector) -> a-value`\n \n When `computation function` is called, the `query-vector` argument will be the vector supplied to the \n the `subscribe` which caused the node to be created. So, if the call was `(subscribe [:sub-id 3 \"blue\"])`, \n then the `query-vector` supplied to the computaton function will be `[:sub-id 3 \"blue\"]`.\n\n The arguments supplied between the `query-id` and the `computation-function` can vary in 3 ways, \n but whatever is there defines the `input signals` part of the template, controlling what input \nvalues \"flow into\" the `computation function` gets when it is called. \n\n `reg-sub` can be called in one of three ways, because there are three ways to define the input signals part.\n But note, the 2nd method, in which a `signal-fn` is explicitly supplied, is the most canonical and instructive. The other \n two are really just sugary variations. \n\n 1. No input signals given:\n     ```clj\n    (reg-sub\n      :query-id\n      a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n    ```\n\n    In the absence of an explicit `input-fn`, the node's input signal defaults to `app-db`\n    and, as a result, the value within `app-db` (a map) is\n    is given as the 1st argument when `a-computation-fn` is called.   \n\n\n 2. A signal function is explicitly supplied:\n    ```clj\n    (reg-sub\n      :query-id\n      signal-fn     ;; <-- here\n      computation-fn)\n    ```\n    \n    This is the most canonical and instructive of the three variations.\n    \n    When a node is created from the template, the `signal-fn` will be called and it\n    is expected to return the input signal(s) as either a singleton, if there is only\n    one, or a sequence if there are many, or a map with the signals as the values.\n\n    The values from returned nominated signals will be supplied as the 1st argument to  \n    the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns, \n    this value will be either a singleton, sequence or map of them (paralleling\n    the structure returned by the `signal-fn`).\n\n    This example `signal-fn` returns a vector of input signals.\n      ```clj\n      (fn [query-vec dynamic-vec]\n        [(subscribe [:a-sub])\n         (subscribe [:b-sub])])\n      ```\n    The associated computation function must be written\n    to expect a vector of values for its first argument:\n      ```clj\n      (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\n        ....)\n       ```\n\n    If, on the other hand, the signal function was simpler and returned a singleton, like this:\n       ```clj\n       (fn [query-vec dynamic-vec]\n         (subscribe [:a-sub]))\n       ```\n    then the associated computation function must be written to expect a single value\n    as the 1st argument:\n       ```clj\n       (fn [a query-vec]       ;; 1st argument is a single value\n         ...)\n       ```\n\n    Further Note: variation #1 above, in which an `input-fn` was not supplied, like this:\n      ```clj\n    (reg-sub\n      :query-id\n      a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n    ```\n    is the equivalent of using this\n    2nd variation and explicitly suppling a `signal-fn` which returns `app-db`:\n    ```clj\n    (reg-sub\n      :query-id\n      (fn [_ _]  re-frame/app-db)   ;; <--- explicit input-fn \n      a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\n    ```\n\n 3. Syntax Sugar\n\n    ```clj\n    (reg-sub\n      :a-b-sub\n      :<- [:a-sub]\n      :<- [:b-sub]\n      (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\n        {:a a :b b}))\n    ```\n\n    This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\n    `signals-fn` you provide one or more pairs of `:<-` and a subscription vector.\n\n    If you supply only one pair a singleton will be supplied to the computation function, \n    as if you had supplied a `signal-fn` returning only a single value:\n\n    ```clj\n    (reg-sub\n      :a-sub\n      :<- [:a-sub]\n      (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\n        ...))\n    ```\n\n For further understanding, read `/docs`, and look at the detailed comments in\n /examples/todomvc/src/subs.cljs\n ",
                               :type :var}
                              {:name subscribe,
                               :file "re_frame/subs.cljc",
                               :line 74,
                               :arglists ([query] [query dynv]),
                               :doc "Given a `query`, returns a Reagent `reaction` which, over\ntime, reactively delivers a stream of values. So in FRP-ish terms,\nit returns a `Signal`.\n\nTo obtain the returned Signal/Stream's current value, it must be `deref`ed.\n\n`query` is a vector of at least one element. The first element is the\n`query-id`, typically a namespaced keyword. The rest of the vector's\nelements are optional, additional values which parameterise the query\nperformed.\n\n`dynv` is an optional 3rd argument, which is a vector of further input\nsignals (atoms, reactions, etc), NOT values. This argument exists for\nhistorical reasons and is borderline deprecated these days.\n\nExample Usage:\n--------------\n\n  (subscribe [:items])\n  (subscribe [:items \"blue\" :small])\n  (subscribe [:items {:colour \"blue\"  :size :small}])\n\nNote: for any given call to `subscribe` there must have been a previous call\nto `reg-sub`, registering the query handler (function) for the `query-id` given.\n\nHint\n----\n\nWhen used in a view function BE SURE to `deref` the returned value.\nIn fact, to avoid any mistakes, some prefer to define:\n\n   (def <sub  (comp deref re-frame.core/subscribe))\n\nAnd then, within their views, they call  `(<sub [:items :small])` rather\nthan using `subscribe` directly.\n\nDe-duplication\n--------------\n\nXXX\n",
                               :type :var}
                              {:name to-seq,
                               :file "re_frame/subs.cljc",
                               :line 181,
                               :arglists ([x]),
                               :doc "Coerces x to a seq if it isn't one already\n",
                               :type :var})}
                   {:doc "Tracing for re-frame.\nAlpha quality, subject to change/break at any time.",
                    :name re-frame.trace,
                    :publics ({:name *current-trace*,
                               :file "re_frame/trace.cljc",
                               :line 12,
                               :dynamic true,
                               :type :var}
                              {:name debounce,
                               :file "re_frame/trace.cljc",
                               :line 69,
                               :arglists ([f interval]),
                               :type :var}
                              {:name debounce-time,
                               :file "re_frame/trace.cljc",
                               :line 67,
                               :type :var}
                              {:name finish-trace,
                               :file "re_frame/trace.cljc",
                               :line 100,
                               :arglists ([trace]),
                               :type :macro}
                              {:name id,
                               :file "re_frame/trace.cljc",
                               :line 11,
                               :type :var}
                              {:name is-trace-enabled?,
                               :file "re_frame/trace.cljc",
                               :line 20,
                               :arglists ([]),
                               :doc "See https://groups.google.com/d/msg/clojurescript/jk43kmYiMhA/IHglVr_TPdgJ for more details\n",
                               :type :var}
                              {:name merge-trace!,
                               :file "re_frame/trace.cljc",
                               :line 123,
                               :arglists ([m]),
                               :type :macro}
                              {:name next-delivery,
                               :file "re_frame/trace.cljc",
                               :line 31,
                               :type :var}
                              {:name next-id,
                               :file "re_frame/trace.cljc",
                               :line 45,
                               :arglists ([]),
                               :type :var}
                              {:name register-trace-cb,
                               :file "re_frame/trace.cljc",
                               :line 33,
                               :arglists ([key f]),
                               :doc "Registers a tracing callback function which will receive a collection of one or more traces.\nWill replace an existing callback function if it shares the same key.",
                               :type :var}
                              {:name remove-trace-cb,
                               :file "re_frame/trace.cljc",
                               :line 41,
                               :arglists ([key]),
                               :type :var}
                              {:name reset-tracing!,
                               :file "re_frame/trace.cljc",
                               :line 14,
                               :arglists ([]),
                               :type :var}
                              {:name run-tracing-callbacks!,
                               :file "re_frame/trace.cljc",
                               :line 85,
                               :arglists ([now]),
                               :type :var}
                              {:name schedule-debounce,
                               :file "re_frame/trace.cljc",
                               :line 73,
                               :type :var}
                              {:name start-trace,
                               :file "re_frame/trace.cljc",
                               :line 47,
                               :arglists ([{:keys [operation
                                                   op-type
                                                   tags
                                                   child-of]}]),
                               :type :var}
                              {:name trace-cbs,
                               :file "re_frame/trace.cljc",
                               :line 29,
                               :type :var}
                              {:name trace-enabled?,
                               :file "re_frame/trace.cljc",
                               :line 18,
                               :type :var}
                              {:name traces,
                               :file "re_frame/trace.cljc",
                               :line 30,
                               :type :var}
                              {:name with-trace,
                               :file "re_frame/trace.cljc",
                               :line 109,
                               :arglists ([{:keys [operation
                                                   op-type
                                                   tags
                                                   child-of],
                                            :as trace-opts}
                                           &
                                           body]),
                               :doc "Create a trace inside the scope of the with-trace macro\n\nCommon keys for trace-opts\n:op-type - what kind of operation is this? e.g. :sub/create, :render.\n:operation - identifier for the operation, for a subscription it would be the subscription keyword\n:tags - a map of arbitrary kv pairs",
                               :type :macro})}
                   {:name re-frame.utils,
                    :publics ({:name dissoc-in,
                               :file "re_frame/utils.cljc",
                               :line 5,
                               :arglists ([m [k & ks :as keys]]),
                               :doc "Dissociates an entry from a nested associative structure returning a new\nnested structure. keys is a sequence of keys. Any empty maps that result\nwill not be present in the new structure.\nThe key thing is that 'm' remains identical? to istelf if the path was never present",
                               :type :var}
                              {:name first-in-vector,
                               :file "re_frame/utils.cljc",
                               :line 20,
                               :arglists ([v]),
                               :type :var})}),
            "cljs" ({:name re-frame.cofx,
                     :publics ({:name inject-cofx,
                                :file "re_frame/cofx.cljc",
                                :line 29,
                                :arglists ([id] [id value]),
                                :doc "Given an `id`, and an optional, arbitrary `value`, returns an interceptor\nwhose `:before` adds to the `:coeffects` (map) by calling a pre-registered\n'coeffect handler' identified by the `id`.\n\nThe previous association of a `coeffect handler` with an `id` will have\nhappened via a call to `re-frame.core/reg-cofx` - generally on program startup.\n\nWithin the created interceptor, this 'looked up' `coeffect handler` will\nbe called (within the `:before`) with two arguments:\n  - the current value of `:coeffects`\n  - optionally, the originally supplied arbitrary `value`\n\nThis `coeffect handler` is expected to modify and return its first, `coeffects` argument.\n\nExample Of how `inject-cofx` and `reg-cofx` work together\n---------------------------------------------------------\n\n1. Early in app startup, you register a `coeffect handler` for `:datetime`:\n\n   (re-frame.core/reg-cofx\n     :datetime                        ;; usage  (inject-cofx :datetime)\n     (fn coeffect-handler\n       [coeffect]\n       (assoc coeffect :now (js/Date.))))   ;; modify and return first arg\n\n2. Later, add an interceptor to an -fx event handler, using `inject-cofx`:\n\n   (re-frame.core/reg-event-fx        ;; we are registering an event handler\n      :event-id\n      [ ... (inject-cofx :datetime) ... ]    ;; <-- create an injecting interceptor\n      (fn event-handler\n        [coeffect event]\n        ... in here can access (:now coeffect) to obtain current datetime ... )))\n\nBackground\n----------\n\n`coeffects` are the input resources required by an event handler\nto perform its job. The two most obvious ones are `db` and `event`.\nBut sometimes an event handler might need other resources.\n\nPerhaps an event handler needs a random number or a GUID or the current\ndatetime. Perhaps it needs access to a DataScript database connection.\n\nIf an event handler directly accesses these resources, it stops being\npure and, consequently, it becomes harder to test, etc. So we don't\nwant that.\n\nInstead, the interceptor created by this function is a way to 'inject'\n'necessary resources' into the `:coeffects` (map) subsequently given\nto the event handler at call time.",
                                :type :var}
                               {:name inject-db,
                                :file "re_frame/cofx.cljc",
                                :line 112,
                                :type :var}
                               {:name kind,
                                :file "re_frame/cofx.cljc",
                                :line 11,
                                :type :var}
                               {:name reg-cofx,
                                :file "re_frame/cofx.cljc",
                                :line 14,
                                :arglists ([id handler]),
                                :doc "Register the given coeffect `handler` for the given `id`, for later use\nwithin `inject-cofx`.\n\n`id` is keyword, often namespaced.\n`handler` is a function which takes either one or two arguements, the first of which is\nalways `coeffects` and which returns an updated `coeffects`.\n\nSee the docs for `inject-cofx` for example use.",
                                :type :var})}
                    {:name re-frame.core,
                     :publics ({:name ->interceptor,
                                :file "re_frame/core.cljc",
                                :line 142,
                                :type :var}
                               {:name add-post-event-callback,
                                :file "re_frame/core.cljc",
                                :line 201,
                                :arglists ([f] [id f]),
                                :doc "Registers a function `f` to be called after each event is processed\n `f` will be called with two arguments:\n  - `event`: a vector. The event just processed.\n  - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\n\n This is useful in advanced cases like:\n   - you are implementing a complex bootstrap pipeline\n   - you want to create your own handling infrastructure, with perhaps multiple\n     handlers for the one event, etc.  Hook in here.\n   - libraries providing 'isomorphic javascript' rendering on  Nodejs or Nashorn.\n\n'id' is typically a keyword. Supplied at \"add time\" so it can subsequently\nbe used at \"remove time\" to get rid of the right callback.\n",
                                :type :var}
                               {:name after,
                                :file "re_frame/core.cljc",
                                :line 126,
                                :type :var}
                               {:name assoc-coeffect,
                                :file "re_frame/core.cljc",
                                :line 144,
                                :type :var}
                               {:name assoc-effect,
                                :file "re_frame/core.cljc",
                                :line 146,
                                :type :var}
                               {:name clear-cofx,
                                :file "re_frame/core.cljc",
                                :line 66,
                                :type :var}
                               {:name clear-event,
                                :file "re_frame/core.cljc",
                                :line 116,
                                :type :var}
                               {:name clear-fx,
                                :file "re_frame/core.cljc",
                                :line 61,
                                :type :var}
                               {:name clear-sub,
                                :file "re_frame/core.cljc",
                                :line 48,
                                :type :var}
                               {:name clear-subscription-cache!,
                                :file "re_frame/core.cljc",
                                :line 49,
                                :type :var}
                               {:name console,
                                :file "re_frame/core.cljc",
                                :line 164,
                                :type :var}
                               {:name debug,
                                :file "re_frame/core.cljc",
                                :line 122,
                                :type :var}
                               {:name dispatch,
                                :file "re_frame/core.cljc",
                                :line 40,
                                :type :var}
                               {:name dispatch-sync,
                                :file "re_frame/core.cljc",
                                :line 41,
                                :type :var}
                               {:name enqueue,
                                :file "re_frame/core.cljc",
                                :line 147,
                                :type :var}
                               {:name enrich,
                                :file "re_frame/core.cljc",
                                :line 124,
                                :type :var}
                               {:name get-coeffect,
                                :file "re_frame/core.cljc",
                                :line 143,
                                :type :var}
                               {:name get-effect,
                                :file "re_frame/core.cljc",
                                :line 145,
                                :type :var}
                               {:name inject-cofx,
                                :file "re_frame/core.cljc",
                                :line 65,
                                :type :var}
                               {:name make-restore-fn,
                                :file "re_frame/core.cljc",
                                :line 169,
                                :arglists ([]),
                                :doc "Checkpoints the state of re-frame and returns a function which, when\nlater called, will restore re-frame to that checkpointed state.\n\nCheckpoint includes app-db, all registered handlers and all subscriptions.\n",
                                :type :var}
                               {:name on-changes,
                                :file "re_frame/core.cljc",
                                :line 127,
                                :type :var}
                               {:name path,
                                :file "re_frame/core.cljc",
                                :line 123,
                                :type :var}
                               {:name purge-event-queue,
                                :file "re_frame/core.cljc",
                                :line 194,
                                :arglists ([]),
                                :doc "Remove all events queued for processing\n",
                                :type :var}
                               {:name reg-cofx,
                                :file "re_frame/core.cljc",
                                :line 64,
                                :type :var}
                               {:name reg-event-ctx,
                                :file "re_frame/core.cljc",
                                :line 104,
                                :arglists ([id handler]
                                           [id interceptors handler]),
                                :doc "Register the given event `handler` (function) for the given `id`. Optionally, provide\nan `interceptors` chain.\n`id` is typically a namespaced keyword  (but can be anything)\n`handler` is a function: (context-map event-vector) -> context-map\n\nThis form of registration is almost never used. ",
                                :type :var}
                               {:name reg-event-db,
                                :file "re_frame/core.cljc",
                                :line 71,
                                :arglists ([id handler]
                                           [id interceptors handler]),
                                :doc "Register the given event `handler` (function) for the given `id`. Optionally, provide\nan `interceptors` chain.\n`id` is typically a namespaced keyword  (but can be anything)\n`handler` is a function: (db event) -> db\n`interceptors` is a collection of interceptors. Will be flattened and nils removed.\n`handler` is wrapped in its own interceptor and added to the end of the interceptor\n chain, so that, in the end, only a chain is registered.\n Special effects and coeffects interceptors are added to the front of this\n chain.",
                                :type :var}
                               {:name reg-event-fx,
                                :file "re_frame/core.cljc",
                                :line 87,
                                :arglists ([id handler]
                                           [id interceptors handler]),
                                :doc "Register the given event `handler` (function) for the given `id`. Optionally, provide\nan `interceptors` chain.\n`id` is typically a namespaced keyword  (but can be anything)\n`handler` is a function: (coeffects-map event-vector) -> effects-map\n`interceptors` is a collection of interceptors. Will be flattened and nils removed.\n`handler` is wrapped in its own interceptor and added to the end of the interceptor\n chain, so that, in the end, only a chain is registered.\n Special effects and coeffects interceptors are added to the front of the\n interceptor chain.  These interceptors inject the value of app-db into coeffects,\n and, later, action effects.",
                                :type :var}
                               {:name reg-fx,
                                :file "re_frame/core.cljc",
                                :line 60,
                                :type :var}
                               {:name reg-sub,
                                :file "re_frame/core.cljc",
                                :line 45,
                                :type :var}
                               {:name reg-sub-raw,
                                :file "re_frame/core.cljc",
                                :line 51,
                                :arglists ([query-id handler-fn]),
                                :doc "This is a low level, advanced function.  You should probably be\nusing reg-sub instead.\nDocs in https://github.com/day8/re-frame/blob/master/docs/SubscriptionFlow.md",
                                :type :var}
                               {:name register-handler,
                                :file "re_frame/core.cljc",
                                :line 229,
                                :arglists ([& args]),
                                :type :var}
                               {:name register-sub,
                                :file "re_frame/core.cljc",
                                :line 234,
                                :arglists ([& args]),
                                :type :var}
                               {:name remove-post-event-callback,
                                :file "re_frame/core.cljc",
                                :line 222,
                                :arglists ([id]),
                                :type :var}
                               {:name set-loggers!,
                                :file "re_frame/core.cljc",
                                :line 157,
                                :type :var}
                               {:name subscribe,
                                :file "re_frame/core.cljc",
                                :line 46,
                                :type :var}
                               {:name trim-v,
                                :file "re_frame/core.cljc",
                                :line 125,
                                :type :var})}
                    {:name re-frame.db,
                     :publics ({:name app-db,
                                :file "re_frame/db.cljc",
                                :line 10,
                                :type :var})}
                    {:name re-frame.events,
                     :publics ({:name *handling*,
                                :file "re_frame/events.cljc",
                                :line 51,
                                :dynamic true,
                                :type :var}
                               {:name handle,
                                :file "re_frame/events.cljc",
                                :line 53,
                                :arglists ([event-v]),
                                :doc "Given an event vector `event-v`, look up the associated interceptor chain, and execute it.\n",
                                :type :var}
                               {:name kind,
                                :file "re_frame/events.cljc",
                                :line 11,
                                :type :var}
                               {:name register,
                                :file "re_frame/events.cljc",
                                :line 35,
                                :arglists ([id interceptors]),
                                :doc "Associate the given event `id` with the given collection of `interceptors`.\n\n`interceptors` may contain nested collections and there may be nils\nat any level,so process this structure into a simple, nil-less vector\nbefore registration.\n\nTypically, an `event handler` will be at the end of the chain (wrapped\nin an interceptor).",
                                :type :var})}
                    {:name re-frame.fx,
                     :publics ({:name do-fx,
                                :file "re_frame/fx.cljc",
                                :line 47,
                                :doc "An interceptor whose `:after` actions the contents of `:effects`. As a result,\nthis interceptor is Domino 3.\n\nThis interceptor is silently added (by reg-event-db etc) to the front of\ninterceptor chains for all events.\n\nFor each key in `:effects` (a map), it calls the registered `effects handler`\n(see `reg-fx` for registration of effect handlers).\n\nSo, if `:effects` was:\n    {:dispatch  [:hello 42]\n     :db        {...}\n     :undo      \"set flag\"}\n\nit will call the registered effect handlers for each of the map's keys:\n`:dispatch`, `:undo` and `:db`. When calling each handler, provides the map\nvalue for that key - so in the example above the effect handler for :dispatch\nwill be given one arg `[:hello 42]`.\n\nYou cannot rely on the ordering in which effects are executed.",
                                :type :var}
                               {:name kind,
                                :file "re_frame/fx.cljc",
                                :line 15,
                                :type :var}
                               {:name reg-fx,
                                :file "re_frame/fx.cljc",
                                :line 18,
                                :arglists ([id handler]),
                                :doc "Register the given effect `handler` for the given `id`.\n\n`id` is keyword, often namespaced.\n`handler` is a side-effecting function which takes a single argument and whose return\nvalue is ignored.\n\nExample Use\n-----------\n\nFirst, registration ... associate `:effect2` with a handler.\n\n(reg-fx\n   :effect2\n   (fn [value]\n      ... do something side-effect-y))\n\nThen, later, if an event handler were to return this effects map ...\n\n{...\n :effect2  [1 2]}\n\n ... then the `handler` `fn` we registered previously, using `reg-fx`, will be\n called with an argument of `[1 2]`.",
                                :type :var})}
                    {:name re-frame.interceptor,
                     :publics ({:name ->interceptor,
                                :file "re_frame/interceptor.cljc",
                                :line 17,
                                :arglists ([&
                                            {:as m,
                                             :keys [id before after]}]),
                                :doc "Create an interceptor from named arguments\n",
                                :type :var}
                               {:name assoc-coeffect,
                                :file "re_frame/interceptor.cljc",
                                :line 57,
                                :arglists ([context key value]),
                                :type :var}
                               {:name assoc-effect,
                                :file "re_frame/interceptor.cljc",
                                :line 39,
                                :arglists ([context key value]),
                                :type :var}
                               {:name enqueue,
                                :file "re_frame/interceptor.cljc",
                                :line 112,
                                :arglists ([context interceptors]),
                                :doc "Add a collection of `interceptors` to the end of `context's` execution `:queue`.\nReturns the updated `context`.\n\nIn an advanced case, this function could allow an interceptor to add new\ninterceptors to the `:queue` of a context.",
                                :type :var}
                               {:name execute,
                                :file "re_frame/interceptor.cljc",
                                :line 149,
                                :arglists ([event-v interceptors]),
                                :doc "Executes the given chain (coll) of interceptors.\n\nEach interceptor has this form:\n    {:before  (fn [context] ...)     ;; returns possibly modified context\n     :after   (fn [context] ...)}    ;; `identity` would be a noop\n\nWalks the queue of iterceptors from beginning to end, calling the\n`:before` fn on each, then reverse direction and walk backwards,\ncalling the `:after` fn on each.\n\nThe last interceptor in the chain presumably wraps an event\nhandler fn. So the overall goal of the process is to \"handle\nthe given event\".\n\nThread a `context` through all calls. `context` has this form:\n\n  {:coeffects {:event [:a-query-id :some-param]\n               :db    <original contents of app-db>}\n   :effects   {:db    <new value for app-db>\n               :dispatch  [:an-event-id :param1]}\n   :queue     <a collection of further interceptors>\n   :stack     <a collection of interceptors already walked>}\n\n`context` has `:coeffects` and `:effects` which, if this was a web\nserver, would be somewhat anologous to `request` and `response`\nrespectively.\n\n`coeffects` will contain data like `event` and the initial\nstate of `db` -  the inputs required by the event handler\n(sitting presumably on the end of the chain), while handler-returned\nside effects are put into `:effects` including, but not limited to,\nnew values for `db`.\n\nThe first few interceptors in a chain will likely have `:before`\nfunctions which \"prime\" the `context` by adding the event, and\nthe current state of app-db into `:coeffects`. But interceptors can\nadd whatever they want to `:coeffects` - perhaps the event handler needs\nsome information from localstore, or a random number, or access to\na DataScript connection.\n\nEqually, some interceptors in the chain will have `:after` fn\nwhich can process the side effects accumulated into `:effects`\nincluding but, not limited to, updates to app-db.\n\nThrough both stages (before and after), `context` contains a `:queue`\nof interceptors yet to be processed, and a `:stack` of interceptors\nalready done.  In advanced cases, these values can be modified by the\nfunctions through which the context is threaded.",
                                :type :var}
                               {:name get-coeffect,
                                :file "re_frame/interceptor.cljc",
                                :line 49,
                                :arglists ([context]
                                           [context key]
                                           [context key not-found]),
                                :type :var}
                               {:name get-effect,
                                :file "re_frame/interceptor.cljc",
                                :line 31,
                                :arglists ([context]
                                           [context key]
                                           [context key not-found]),
                                :type :var}
                               {:name interceptor?,
                                :file "re_frame/interceptor.cljc",
                                :line 11,
                                :arglists ([m]),
                                :type :var}
                               {:name mandatory-interceptor-keys,
                                :file "re_frame/interceptor.cljc",
                                :line 9,
                                :type :var}
                               {:name update-coeffect,
                                :file "re_frame/interceptor.cljc",
                                :line 61,
                                :arglists ([context key f & args]),
                                :type :var}
                               {:name update-effect,
                                :file "re_frame/interceptor.cljc",
                                :line 43,
                                :arglists ([context key f & args]),
                                :type :var})}
                    {:name re-frame.interop,
                     :publics ({:name add-on-dispose!,
                                :file "re_frame/interop.cljs",
                                :line 31,
                                :arglists ([a-ratom f]),
                                :type :var}
                               {:name after-render,
                                :file "re_frame/interop.cljs",
                                :line 10,
                                :type :var}
                               {:name debug-enabled?,
                                :file "re_frame/interop.cljs",
                                :line 16,
                                :doc "@define {boolean}\n",
                                :type :var}
                               {:name deref?,
                                :file "re_frame/interop.cljs",
                                :line 24,
                                :arglists ([x]),
                                :type :var}
                               {:name dispose!,
                                :file "re_frame/interop.cljs",
                                :line 34,
                                :arglists ([a-ratom]),
                                :type :var}
                               {:name empty-queue,
                                :file "re_frame/interop.cljs",
                                :line 8,
                                :type :var}
                               {:name make-reaction,
                                :file "re_frame/interop.cljs",
                                :line 28,
                                :arglists ([f]),
                                :type :var}
                               {:name next-tick,
                                :file "re_frame/interop.cljs",
                                :line 6,
                                :type :var}
                               {:name now,
                                :file "re_frame/interop.cljs",
                                :line 40,
                                :arglists ([]),
                                :type :var}
                               {:name ratom,
                                :file "re_frame/interop.cljs",
                                :line 18,
                                :arglists ([x]),
                                :type :var}
                               {:name ratom?,
                                :file "re_frame/interop.cljs",
                                :line 21,
                                :arglists ([x]),
                                :type :var}
                               {:name reagent-id,
                                :file "re_frame/interop.cljs",
                                :line 47,
                                :arglists ([reactive-val]),
                                :doc "Produces an id for reactive Reagent values\ne.g. reactions, ratoms, cursors.",
                                :type :var}
                               {:name set-timeout!,
                                :file "re_frame/interop.cljs",
                                :line 37,
                                :arglists ([f ms]),
                                :type :var})}
                    {:name re-frame.loggers,
                     :publics ({:name console,
                                :file "re_frame/loggers.cljc",
                                :line 37,
                                :arglists ([level & args]),
                                :type :var}
                               {:name get-loggers,
                                :file "re_frame/loggers.cljc",
                                :line 50,
                                :arglists ([]),
                                :doc "Get the current logging functions used by re-frame.\n",
                                :type :var}
                               {:name set-loggers!,
                                :file "re_frame/loggers.cljc",
                                :line 43,
                                :arglists ([new-loggers]),
                                :doc "Change the set (or a subset) of logging functions used by re-frame.\n`new-loggers` should be a map with the same keys as `loggers` (above)",
                                :type :var})}
                    {:name re-frame.registrar,
                     :doc "In many places, re-frame asks you to associate an `id` (keyword)\nwith a `handler` (function).  This namespace contains the\ncentral registry of such associations.",
                     :publics ({:name clear-handlers,
                                :file "re_frame/registrar.cljc",
                                :line 44,
                                :arglists ([] [kind] [kind id]),
                                :type :var}
                               {:name get-handler,
                                :file "re_frame/registrar.cljc",
                                :line 18,
                                :arglists ([kind]
                                           [kind id]
                                           [kind id required?]),
                                :type :var}
                               {:name kind->id->handler,
                                :file "re_frame/registrar.cljc",
                                :line 15,
                                :type :var}
                               {:name kinds,
                                :file "re_frame/registrar.cljc",
                                :line 10,
                                :type :var}
                               {:name register-handler,
                                :file "re_frame/registrar.cljc",
                                :line 35,
                                :arglists ([kind id handler-fn]),
                                :type :var})}
                    {:name re-frame.router,
                     :publics ({:name dispatch,
                                :file "re_frame/router.cljc",
                                :line 233,
                                :arglists ([event]),
                                :doc "Enqueue `event` for processing by event handling machinery.\n\n`event` is a vector of length >= 1. The 1st element identifies the kind of event.\n\nNote: the event handler is not run immediately - it is not run\nsynchronously. It will likely be run 'very soon', although it may be\nadded to the end of a FIFO queue which already contain events.\n\nUsage:\n   (dispatch [:order-pizza {:supreme 2 :meatlovers 1 :veg 1})",
                                :type :var}
                               {:name dispatch-sync,
                                :file "re_frame/router.cljc",
                                :line 251,
                                :arglists ([event-v]),
                                :doc "Synchronously (immediately) process `event`. Do not queue.\n\nGenerally, don't use this. Instead use `dispatch`. It is an error\nto use `dispatch-sync` within an event handler.\n\nUseful when any delay in processing is a problem:\n   1. the `:on-change` handler of a text field where we are expecting fast typing.\n   2  when initialising your app - see 'main' in todomvc examples\n   3. in a unit test where we don't want the action 'later'\n\nUsage:\n   (dispatch-sync [:sing :falsetto 634])",
                                :type :var}
                               {:name event-queue,
                                :file "re_frame/router.cljc",
                                :line 226,
                                :type :var}
                               {:name EventQueue,
                                :file "re_frame/router.cljc",
                                :line 94,
                                :type :var}
                               {:name IEventQueue,
                                :file "re_frame/router.cljc",
                                :line 71,
                                :type :protocol,
                                :members ({:name -add-event,
                                           :arglists ([this event]),
                                           :type :var}
                                          {:name -call-post-event-callbacks,
                                           :arglists ([this event]),
                                           :type :var}
                                          {:name -exception,
                                           :arglists ([this ex]),
                                           :type :var}
                                          {:name -fsm-trigger,
                                           :arglists ([this
                                                       trigger
                                                       arg]),
                                           :type :var}
                                          {:name -pause,
                                           :arglists ([this later-fn]),
                                           :type :var}
                                          {:name -process-1st-event-in-queue,
                                           :arglists ([this]),
                                           :type :var}
                                          {:name -resume,
                                           :arglists ([this]),
                                           :type :var}
                                          {:name -run-next-tick,
                                           :arglists ([this]),
                                           :type :var}
                                          {:name -run-queue,
                                           :arglists ([this]),
                                           :type :var}
                                          {:name add-post-event-callback,
                                           :arglists ([this
                                                       id
                                                       callack]),
                                           :type :var}
                                          {:name purge,
                                           :arglists ([this]),
                                           :type :var}
                                          {:name push,
                                           :arglists ([this event]),
                                           :type :var}
                                          {:name remove-post-event-callback,
                                           :arglists ([this f]),
                                           :type :var})}
                               {:name later-fns,
                                :file "re_frame/router.cljc",
                                :line 65,
                                :type :var})}
                    {:name re-frame.std-interceptors,
                     :doc "contains re-frame supplied, standard interceptors\n",
                     :publics ({:name after,
                                :file "re_frame/std_interceptors.cljc",
                                :line 295,
                                :arglists ([f]),
                                :doc "returns an interceptor which runs a given function `f` in the `:after`\nposition, presumably for side effects.\n\n`f` is called with two arguments: the `:effects` value for `:db`\n(or the `coeffect` value of db if no db effect is returned) and the event.\nIts return value is ignored, so `f` can only side-effect.\n\nExamples use can be seen in the /examples/todomvc:\n   - `f` runs schema validation (reporting any errors found).\n   - `f` writes to localstorage.",
                                :type :var}
                               {:name ctx-handler->interceptor,
                                :file "re_frame/std_interceptors.cljc",
                                :line 156,
                                :arglists ([handler-fn]),
                                :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-ctx`.\nThese advanced handlers take one argument: `context` and they return a modified `context`.\nExample:\n\n    (fn [context]\n       (enqueue context [more interceptors]))",
                                :type :var}
                               {:name db-handler->interceptor,
                                :file "re_frame/std_interceptors.cljc",
                                :line 93,
                                :arglists ([handler-fn]),
                                :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-db`.\n\nThese handlers take two arguments;  `db` and `event`, and they return `db`.\n\n    (fn [db event]\n       ....)\n\nSo, the interceptor wraps the given handler:\n   1. extracts two `:coeffects` keys: db and event\n   2. calls handler-fn\n   3. stores the db result back into context's `:effects`",
                                :type :var}
                               {:name debug,
                                :file "re_frame/std_interceptors.cljc",
                                :line 14,
                                :doc "An interceptor which logs/instruments an event handler's actions to\n`js/console.debug`. See examples/todomvc/src/events.cljs for use.\n\nOutput includes:\n1. the event vector\n2. a `clojure.data/diff` of db, before vs after, which shows\n   the changes caused by the event handler.  You will absolutely have\n   to understand https://clojuredocs.org/clojure.data/diff to\n   understand the output.\n\nYou'd typically include this interceptor after (to the right of) any\npath interceptor.\n\nWarning:  calling clojure.data/diff on large, complex data structures\ncan be slow. So, you won't want this interceptor present in production\ncode. So condition it out like this :\n\n    (re-frame.core/reg-event-db\n       :evt-id\n       [(when ^boolean goog.DEBUG re-frame.core/debug)]  ;; <-- conditional\n       (fn [db v]\n         ...))\n\nTo make this code fragment work, you'll also have to set goog.DEBUG to\nfalse in your production builds - look in `project.clj` of /examples/todomvc.\n",
                                :type :var}
                               {:name enrich,
                                :file "re_frame/std_interceptors.cljc",
                                :line 237,
                                :arglists ([f]),
                                :doc "Interceptor factory which runs the given function `f` in the `after handler`\nposition.  `f` is called with two arguments: `db` and `v`, and is expected to\nreturn a modified `db`.\n\nUnlike the `after` interceptor which is only about side effects, `enrich`\nexpects `f` to process and alter the given `db` coeffect in some useful way,\ncontributing to the derived data, flowing vibe.\n\nExample Use:\n------------\n\nImagine that todomvc needed to do duplicate detection - if any two todos had\nthe same text, then highlight their background, and report them via a warning\nat the bottom of the panel.\n\nAlmost any user action (edit text, add new todo, remove a todo) requires a\ncomplete reassessment of duplication errors and warnings. Eg: that edit\njust made might have introduced a new duplicate, or removed one. Same with\nany todo removal. So we need to re-calculate warnings after any CRUD events\nassociated with the todos list.\n\nUnless we are careful, we might end up coding subtly different checks\nfor each kind of CRUD operation.  The duplicates check made after\n'delete todo' event might be subtly different to that done after an\nediting operation. Nice and efficient, but fiddly. A bug generator\napproach.\n\nSo, instead, we create an `f` which recalculates ALL warnings from scratch\nevery time there is ANY change. It will inspect all the todos, and\nreset ALL FLAGS every time (overwriting what was there previously)\nand fully recalculate the list of duplicates (displayed at the bottom?).\n\nhttps://twitter.com/nathanmarz/status/879722740776939520\n\nBy applying `f` in an `:enrich` interceptor, after every CRUD event,\nwe keep the handlers simple and yet we ensure this important step\n(of getting warnings right) is not missed on any change.\n\nWe can test `f` easily - it is a pure function - independently of\nany CRUD operation.\n\nThis brings huge simplicity at the expense of some re-computation\neach time. This may be a very satisfactory trade-off in many cases.",
                                :type :var}
                               {:name fx-handler->interceptor,
                                :file "re_frame/std_interceptors.cljc",
                                :line 125,
                                :arglists ([handler-fn]),
                                :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-fx`.\n\nThese handlers take two arguments;  `coeffects` and `event`, and they return `effects`.\n\n    (fn [coeffects event]\n       {:db ...\n        :dispatch ...})\n\n Wrap handler in an interceptor so it can be added to (the RHS) of a chain:\n   1. extracts `:coeffects`\n   2. call handler-fn giving coeffects\n   3. stores the result back into the `:effects`",
                                :type :var}
                               {:name on-changes,
                                :file "re_frame/std_interceptors.cljc",
                                :line 319,
                                :arglists ([f out-path & in-paths]),
                                :doc "Interceptor factory which acts a bit like `reaction`  (but it flows into\n`db`, rather than out). It observes N paths within `db` and if any of them\ntest not identical? to their previous value  (as a result of a event handler\nbeing run) then it runs `f` to compute a new value, which is then assoc-ed\ninto the given `out-path` within `db`.\n\nUsage:\n\n    (defn my-f\n      [a-val b-val]\n      ... some computation on a and b in here)\n\n    (on-changes my-f [:c]  [:a] [:b])\n\nPut this Interceptor on the right handlers (ones which might change :a or :b).\nIt will:\n   - call `f` each time the value at path [:a] or [:b] changes\n   - call `f` with the values extracted from [:a] [:b]\n   - assoc the return value from `f` into the path  [:c]\n",
                                :type :var}
                               {:name path,
                                :file "re_frame/std_interceptors.cljc",
                                :line 182,
                                :arglists ([& args]),
                                :doc "returns an interceptor whose `:before` substitutes the coeffects `:db` with\na sub-path of `:db`. Within `:after` it grafts the handler's return value\nback into db, at the right path.\n\nSo, its overall action is to make the event handler behave like the function\nyou might give to clojure's `update-in`.\n\nExamples:\n\n    (path :some :path)\n    (path [:some :path])\n    (path [:some :path] :to :here)\n    (path [:some :path] [:to] :here)\n\nExample Use:\n\n    (reg-event-db\n      :event-id\n      (path [:a :b])  ;; used here, in interceptor chain\n      (fn [b v]       ;; 1st arg is now not db. Is the value from path [:a :b] within db\n        ... new-b))   ;; returns a new value for that path (not the entire db)\n\nNotes:\n  1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\n  2. if `:effects` contains no `:db` effect, can't graft a value back in.\n",
                                :type :var}
                               {:name trim-v,
                                :file "re_frame/std_interceptors.cljc",
                                :line 65,
                                :doc "An interceptor which removes the first element of the event vector,\nallowing you to write more aesthetically pleasing event handlers. No\nleading underscore on the event-v!\nYour event handlers will look like this:\n\n    (defn my-handler\n      [db [x y z]]    ;; <-- instead of [_ x y z]\n      ....)",
                                :type :var})}
                    {:name re-frame.subs,
                     :publics ({:name cache-and-return,
                                :file "re_frame/subs.cljc",
                                :line 42,
                                :arglists ([query-v dynv r]),
                                :doc "cache the reaction r\n",
                                :type :var}
                               {:name cache-lookup,
                                :file "re_frame/subs.cljc",
                                :line 65,
                                :arglists ([query-v] [query-v dyn-v]),
                                :type :var}
                               {:name clear-all-handlers!,
                                :file "re_frame/subs.cljc",
                                :line 36,
                                :arglists ([]),
                                :doc "Unregisters all existing subscription handlers\n",
                                :type :var}
                               {:name clear-subscription-cache!,
                                :file "re_frame/subs.cljc",
                                :line 20,
                                :arglists ([]),
                                :doc "Causes all subscriptions to be removed from the cache.\nDoes this by:\n   1. running `on-dispose` on all cached subscriptions\n   2. Each `on-dispose` will perform the removal of themselves.\n\nThis is for development time use. Useful when reloading Figwheel code\nafter a React exception, because React components won't have been\ncleaned up properly. And this, in turn, means the subscriptions within those\ncomponents won't have been cleaned up correctly. So this forces the issue.",
                                :type :var}
                               {:name kind,
                                :file "re_frame/subs.cljc",
                                :line 10,
                                :type :var}
                               {:name map-signals,
                                :file "re_frame/subs.cljc",
                                :line 171,
                                :arglists ([f signals]),
                                :doc "Runs f over signals. Signals may take several\nforms, this function handles all of them.",
                                :type :var}
                               {:name query->reaction,
                                :file "re_frame/subs.cljc",
                                :line 18,
                                :type :var}
                               {:name reg-sub,
                                :file "re_frame/subs.cljc",
                                :line 200,
                                :arglists ([query-id & args]),
                                :doc "For a given `query-id`, register two functions: a `computation` function and an `input signals` function.\n \n During program execution, a call to `subscribe`, such as `(subscribe [:sub-id 3 \"blue\"])`,\n will create a new `:sub-id` node in the Signal Graph. And, at that time, re-frame\n needs to know how to create the node.   By calling `reg-sub`, you are registering \n 'the template' or 'the mechanism' by which nodes in the Signal Graph can be created. \n\n Repeating: calling `reg-sub` does not create a node. It only creates the template\n from which nodes can be created later. \n \n `reg-sub` arguments are:  \n   - a `query-id` (typically a namespaced keyword)\n   - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways) \n   - a function which computes the value of this kind of node \n\n The `computation function` is always the last argument supplied and it is expected to have the signature: \n   `(input-values, query-vector) -> a-value`\n \n When `computation function` is called, the `query-vector` argument will be the vector supplied to the \n the `subscribe` which caused the node to be created. So, if the call was `(subscribe [:sub-id 3 \"blue\"])`, \n then the `query-vector` supplied to the computaton function will be `[:sub-id 3 \"blue\"]`.\n\n The arguments supplied between the `query-id` and the `computation-function` can vary in 3 ways, \n but whatever is there defines the `input signals` part of the template, controlling what input \nvalues \"flow into\" the `computation function` gets when it is called. \n\n `reg-sub` can be called in one of three ways, because there are three ways to define the input signals part.\n But note, the 2nd method, in which a `signal-fn` is explicitly supplied, is the most canonical and instructive. The other \n two are really just sugary variations. \n\n 1. No input signals given:\n     ```clj\n    (reg-sub\n      :query-id\n      a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n    ```\n\n    In the absence of an explicit `input-fn`, the node's input signal defaults to `app-db`\n    and, as a result, the value within `app-db` (a map) is\n    is given as the 1st argument when `a-computation-fn` is called.   \n\n\n 2. A signal function is explicitly supplied:\n    ```clj\n    (reg-sub\n      :query-id\n      signal-fn     ;; <-- here\n      computation-fn)\n    ```\n    \n    This is the most canonical and instructive of the three variations.\n    \n    When a node is created from the template, the `signal-fn` will be called and it\n    is expected to return the input signal(s) as either a singleton, if there is only\n    one, or a sequence if there are many, or a map with the signals as the values.\n\n    The values from returned nominated signals will be supplied as the 1st argument to  \n    the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns, \n    this value will be either a singleton, sequence or map of them (paralleling\n    the structure returned by the `signal-fn`).\n\n    This example `signal-fn` returns a vector of input signals.\n      ```clj\n      (fn [query-vec dynamic-vec]\n        [(subscribe [:a-sub])\n         (subscribe [:b-sub])])\n      ```\n    The associated computation function must be written\n    to expect a vector of values for its first argument:\n      ```clj\n      (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\n        ....)\n       ```\n\n    If, on the other hand, the signal function was simpler and returned a singleton, like this:\n       ```clj\n       (fn [query-vec dynamic-vec]\n         (subscribe [:a-sub]))\n       ```\n    then the associated computation function must be written to expect a single value\n    as the 1st argument:\n       ```clj\n       (fn [a query-vec]       ;; 1st argument is a single value\n         ...)\n       ```\n\n    Further Note: variation #1 above, in which an `input-fn` was not supplied, like this:\n      ```clj\n    (reg-sub\n      :query-id\n      a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n    ```\n    is the equivalent of using this\n    2nd variation and explicitly suppling a `signal-fn` which returns `app-db`:\n    ```clj\n    (reg-sub\n      :query-id\n      (fn [_ _]  re-frame/app-db)   ;; <--- explicit input-fn \n      a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\n    ```\n\n 3. Syntax Sugar\n\n    ```clj\n    (reg-sub\n      :a-b-sub\n      :<- [:a-sub]\n      :<- [:b-sub]\n      (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\n        {:a a :b b}))\n    ```\n\n    This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\n    `signals-fn` you provide one or more pairs of `:<-` and a subscription vector.\n\n    If you supply only one pair a singleton will be supplied to the computation function, \n    as if you had supplied a `signal-fn` returning only a single value:\n\n    ```clj\n    (reg-sub\n      :a-sub\n      :<- [:a-sub]\n      (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\n        ...))\n    ```\n\n For further understanding, read `/docs`, and look at the detailed comments in\n /examples/todomvc/src/subs.cljs\n ",
                                :type :var}
                               {:name subscribe,
                                :file "re_frame/subs.cljc",
                                :line 74,
                                :arglists ([query] [query dynv]),
                                :doc "Given a `query`, returns a Reagent `reaction` which, over\ntime, reactively delivers a stream of values. So in FRP-ish terms,\nit returns a `Signal`.\n\nTo obtain the returned Signal/Stream's current value, it must be `deref`ed.\n\n`query` is a vector of at least one element. The first element is the\n`query-id`, typically a namespaced keyword. The rest of the vector's\nelements are optional, additional values which parameterise the query\nperformed.\n\n`dynv` is an optional 3rd argument, which is a vector of further input\nsignals (atoms, reactions, etc), NOT values. This argument exists for\nhistorical reasons and is borderline deprecated these days.\n\nExample Usage:\n--------------\n\n  (subscribe [:items])\n  (subscribe [:items \"blue\" :small])\n  (subscribe [:items {:colour \"blue\"  :size :small}])\n\nNote: for any given call to `subscribe` there must have been a previous call\nto `reg-sub`, registering the query handler (function) for the `query-id` given.\n\nHint\n----\n\nWhen used in a view function BE SURE to `deref` the returned value.\nIn fact, to avoid any mistakes, some prefer to define:\n\n   (def <sub  (comp deref re-frame.core/subscribe))\n\nAnd then, within their views, they call  `(<sub [:items :small])` rather\nthan using `subscribe` directly.\n\nDe-duplication\n--------------\n\nXXX\n",
                                :type :var}
                               {:name to-seq,
                                :file "re_frame/subs.cljc",
                                :line 181,
                                :arglists ([x]),
                                :doc "Coerces x to a seq if it isn't one already\n",
                                :type :var})}
                    {:name re-frame.trace,
                     :doc "Tracing for re-frame.\nAlpha quality, subject to change/break at any time.",
                     :publics ({:name *current-trace*,
                                :file "re_frame/trace.cljc",
                                :line 12,
                                :dynamic true,
                                :type :var}
                               {:name debounce,
                                :file "re_frame/trace.cljc",
                                :line 69,
                                :arglists ([f interval]),
                                :type :var}
                               {:name debounce-time,
                                :file "re_frame/trace.cljc",
                                :line 67,
                                :type :var}
                               {:name finish-trace,
                                :file "re_frame/trace.cljc",
                                :line 100,
                                :arglists ([trace]),
                                :type :macro}
                               {:name id,
                                :file "re_frame/trace.cljc",
                                :line 11,
                                :type :var}
                               {:name is-trace-enabled?,
                                :file "re_frame/trace.cljc",
                                :line 20,
                                :arglists ([]),
                                :doc "See https://groups.google.com/d/msg/clojurescript/jk43kmYiMhA/IHglVr_TPdgJ for more details\n",
                                :type :var}
                               {:name merge-trace!,
                                :file "re_frame/trace.cljc",
                                :line 123,
                                :arglists ([m]),
                                :type :macro}
                               {:name next-delivery,
                                :file "re_frame/trace.cljc",
                                :line 31,
                                :type :var}
                               {:name next-id,
                                :file "re_frame/trace.cljc",
                                :line 45,
                                :arglists ([]),
                                :type :var}
                               {:name register-trace-cb,
                                :file "re_frame/trace.cljc",
                                :line 33,
                                :arglists ([key f]),
                                :doc "Registers a tracing callback function which will receive a collection of one or more traces.\nWill replace an existing callback function if it shares the same key.",
                                :type :var}
                               {:name remove-trace-cb,
                                :file "re_frame/trace.cljc",
                                :line 41,
                                :arglists ([key]),
                                :type :var}
                               {:name reset-tracing!,
                                :file "re_frame/trace.cljc",
                                :line 14,
                                :arglists ([]),
                                :type :var}
                               {:name run-tracing-callbacks!,
                                :file "re_frame/trace.cljc",
                                :line 85,
                                :arglists ([now]),
                                :type :var}
                               {:name schedule-debounce,
                                :file "re_frame/trace.cljc",
                                :line 73,
                                :type :var}
                               {:name start-trace,
                                :file "re_frame/trace.cljc",
                                :line 47,
                                :arglists ([{:keys [operation
                                                    op-type
                                                    tags
                                                    child-of]}]),
                                :type :var}
                               {:name trace-cbs,
                                :file "re_frame/trace.cljc",
                                :line 29,
                                :type :var}
                               {:name trace-enabled?,
                                :file "re_frame/trace.cljc",
                                :line 17,
                                :type :var}
                               {:name traces,
                                :file "re_frame/trace.cljc",
                                :line 30,
                                :type :var}
                               {:name with-trace,
                                :file "re_frame/trace.cljc",
                                :line 109,
                                :arglists ([{:keys [operation
                                                    op-type
                                                    tags
                                                    child-of],
                                             :as trace-opts}
                                            &
                                            body]),
                                :doc "Create a trace inside the scope of the with-trace macro\n\nCommon keys for trace-opts\n:op-type - what kind of operation is this? e.g. :sub/create, :render.\n:operation - identifier for the operation, for a subscription it would be the subscription keyword\n:tags - a map of arbitrary kv pairs",
                                :type :macro})}
                    {:name re-frame.utils,
                     :publics ({:name dissoc-in,
                                :file "re_frame/utils.cljc",
                                :line 5,
                                :arglists ([m [k & ks :as keys]]),
                                :doc "Dissociates an entry from a nested associative structure returning a new\nnested structure. keys is a sequence of keys. Any empty maps that result\nwill not be present in the new structure.\nThe key thing is that 'm' remains identical? to istelf if the path was never present",
                                :type :var}
                               {:name first-in-vector,
                                :file "re_frame/utils.cljc",
                                :line 20,
                                :arglists ([v]),
                                :type :var})})},
 :pom-str "<?xml version=\"1.0\" encoding=\"UTF-8\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>re-frame</groupId>\n  <artifactId>re-frame</artifactId>\n  <packaging>jar</packaging>\n  <version>0.12.0</version>\n  <name>re-frame</name>\n  <description>A ClojureScript MVC-like Framework For Writing SPAs Using Reagent.</description>\n  <url>https://github.com/day8/re-frame.git</url>\n  <licenses>\n    <license>\n      <name>MIT</name>\n    </license>\n  </licenses>\n  <scm>\n    <url>https://github.com/day8/re-frame</url>\n    <connection>scm:git:git://github.com/day8/re-frame.git</connection>\n    <developerConnection>scm:git:ssh://git@github.com/day8/re-frame.git</developerConnection>\n    <tag>a531e6f99881886f821021c1f651094309c7c02c</tag>\n  </scm>\n  <build>\n    <sourceDirectory>src</sourceDirectory>\n    <testSourceDirectory>test</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>run/resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>run/resources</directory>\n      </testResource>\n    </testResources>\n    <directory>target</directory>\n    <outputDirectory>target/classes</outputDirectory>\n    <plugins/>\n  </build>\n  <repositories>\n    <repository>\n      <id>central</id>\n      <url>https://repo1.maven.org/maven2/</url>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n    <repository>\n      <id>clojars</id>\n      <url>https://repo.clojars.org/</url>\n      <snapshots>\n        <enabled>true</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n  </repositories>\n  <dependencyManagement>\n    <dependencies/>\n  </dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojure</artifactId>\n      <version>1.10.1</version>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojurescript</artifactId>\n      <version>1.10.597</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>closure-compiler-unshaded</artifactId>\n          <groupId>com.google.javascript</groupId>\n        </exclusion>\n        <exclusion>\n          <artifactId>google-closure-library</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n        <exclusion>\n          <artifactId>google-closure-library-third-party</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>thheller</groupId>\n      <artifactId>shadow-cljs</artifactId>\n      <version>2.8.83</version>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>reagent</groupId>\n      <artifactId>reagent</artifactId>\n      <version>0.10.0</version>\n    </dependency>\n    <dependency>\n      <groupId>net.cgrand</groupId>\n      <artifactId>macrovich</artifactId>\n      <version>0.2.1</version>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>tools.logging</artifactId>\n      <version>0.4.1</version>\n    </dependency>\n    <dependency>\n      <groupId>binaryage</groupId>\n      <artifactId>devtools</artifactId>\n      <version>0.9.11</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n<!-- This file was autogenerated by Leiningen.\n  Please do not edit it directly; instead edit project.clj and regenerate it.\n  It should not be considered canonical data. For more information see\n  https://github.com/technomancy/leiningen -->\n"}
