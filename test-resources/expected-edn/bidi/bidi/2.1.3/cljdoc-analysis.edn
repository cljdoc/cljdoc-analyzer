{:group-id "bidi", :artifact-id "bidi", :version "2.1.3", :analysis {"clj" ({:name bidi.bidi, :publics ({:name Alternates, :file "bidi/bidi.cljc", :line 481, :type :var} {:name alts, :file "bidi/bidi.cljc", :line 492, :arglists ([& alts]), :type :var} {:name compile-route, :file "bidi/bidi.cljc", :line 562, :arglists ([route]), :deprecated true, :type :var} {:name handler, :file "bidi/bidi.cljc", :line 521, :arglists ([k handler] [handler]), :deprecated true, :type :var} {:name IdentifiableHandler, :file "bidi/bidi.cljc", :line 512, :type :var} {:name just-path, :file "bidi/bidi.cljc", :line 187, :arglists ([path]), :type :var} {:name match-beginning, :file "bidi/bidi.cljc", :line 203, :arglists ([regex-pattern env]), :doc "Match the beginning of the :remainder value in m. If matched, update\nthe :remainder value in m with the path that remains after matching.", :type :var} {:name match-pair, :file "bidi/bidi.cljc", :line 194, :arglists ([[pattern matched] orig-env]), :doc "A pair contains a pattern to match (either fully or partially) and an\nexpression yielding a handler. The second parameter is a map\ncontaining state, including the remaining path.", :type :var} {:name match-route, :file "bidi/bidi.cljc", :line 385, :arglists ([route path & {:as options}]), :doc "Given a route definition data structure and a path, return the\nhandler, if any, that matches the path.", :type :var} {:name match-route*, :file "bidi/bidi.cljc", :line 380, :arglists ([route path options]), :type :var} {:name Matched, :file "bidi/bidi.cljc", :line 183, :type :protocol, :members ({:name resolve-handler, :arglists ([_ m]), :type :var} {:name unresolve-handler, :arglists ([_ m]), :type :var})} {:name Matches, :file "bidi/bidi.cljc", :line 404, :type :protocol, :members ({:name matches, :arglists ([_]), :doc "A protocol used in the expansion of possible matches that the pattern can match. This is used to gather all possible routes using route-seq below.\n", :type :var})} {:name ParameterEncoding, :file "bidi/bidi.cljc", :line 34, :type :protocol, :members ({:name encode-parameter, :arglists ([_]), :type :var})} {:name path-for, :file "bidi/bidi.cljc", :line 391, :arglists ([route handler & {:as params}]), :doc "Given a route definition data structure, a handler and an option map, return a\npath that would route to the handler. The map must contain the values to any\nparameters required to create the path, and extra values are silently ignored.", :type :var} {:name Pattern, :file "bidi/bidi.cljc", :line 176, :type :protocol, :members ({:name match-pattern, :arglists ([_ env]), :doc "Return a new state if this pattern matches the given state, or\nfalsy otherwise. If a new state is returned it will usually have the\nrest of the path to match in the :remainder entry.", :type :var} {:name unmatch-pattern, :arglists ([_ m]), :type :var})} {:name PatternSegment, :file "bidi/bidi.cljc", :line 71, :type :protocol, :members ({:name matches?, :arglists ([_ s]), :type :var} {:name param-key, :arglists ([_]), :type :var} {:name segment-regex-group, :arglists ([_]), :type :var} {:name transform-param, :arglists ([_]), :type :var} {:name unmatch-segment, :arglists ([_ params]), :type :var})} {:name Route, :file "bidi/bidi.cljc", :line 419, :type :var} {:name route-seq, :file "bidi/bidi.cljc", :line 424, :arglists ([[pattern matched] ctx] [route]), :type :var} {:name RouteProvider, :file "bidi/bidi.cljc", :line 465, :type :protocol, :members ({:name routes, :arglists ([_]), :doc "Provide a bidi route structure. Returns a vector pair,\nthe first element is the pattern, the second element is the matched\nroute or routes.", :type :var})} {:name routes-context, :file "bidi/bidi.cljc", :line 546, :arglists ([routes context]), :doc "Wrap a Matched such that a successful match will merge the given\ncontext with the match-context. The merge is such that where there\nis a conflict, the inner sub-tree overrides the outer container.", :type :var} {:name RoutesContext, :file "bidi/bidi.cljc", :line 533, :type :var} {:name RouteSeq, :file "bidi/bidi.cljc", :line 421, :type :protocol, :members ({:name gather, :arglists ([_ context]), :doc "Return a sequence of leaves\n", :type :var})} {:name succeed, :file "bidi/bidi.cljc", :line 211, :arglists ([handler m]), :type :var} {:name tag, :file "bidi/bidi.cljc", :line 509, :arglists ([matched tag]), :type :var} {:name TaggedMatch, :file "bidi/bidi.cljc", :line 498, :type :var} {:name unmatch-pair, :file "bidi/bidi.cljc", :line 324, :arglists ([v m]), :type :var} {:name url-decode, :file "bidi/bidi.cljc", :line 16, :arglists ([string] [string encoding]), :type :var} {:name url-encode, :file "bidi/bidi.cljc", :line 8, :arglists ([string]), :type :var} {:name uuid, :file "bidi/bidi.cljc", :line 22, :arglists ([s]), :doc "Function for creating a UUID of the appropriate type for the platform.\nNote that this function should _only_ be used in route patterns as, at least\nin the case of ClojureScript, it does not validate that the input string is\nactually a valid UUID (this is handled by the route matching logic).", :type :var})} {:name bidi.ring, :publics ({:name Archive, :file "bidi/ring.cljc", :line 159, :type :var} {:name archive, :file "bidi/ring.cljc", :line 179, :arglists ([options]), :type :var} {:name Files, :file "bidi/ring.cljc", :line 139, :type :var} {:name files, :file "bidi/ring.cljc", :line 152, :arglists ([options]), :type :var} {:name make-handler, :file "bidi/ring.cljc", :line 32, :arglists ([route handler-fn] [route]), :doc "Create a Ring handler from the route definition data\nstructure. Matches a handler from the uri in the request, and invokes\nit with the request as a parameter.", :type :var} {:name Redirect, :file "bidi/ring.cljc", :line 58, :type :var} {:name redirect, :file "bidi/ring.cljc", :line 81, :arglists ([target]), :type :var} {:name redirect-after-post, :file "bidi/ring.cljc", :line 85, :arglists ([target]), :type :var} {:name Resources, :file "bidi/ring.cljc", :line 91, :type :var} {:name resources, :file "bidi/ring.cljc", :line 107, :arglists ([options]), :type :var} {:name resources-maybe, :file "bidi/ring.cljc", :line 133, :arglists ([options]), :type :var} {:name ResourcesMaybe, :file "bidi/ring.cljc", :line 119, :type :var} {:name Ring, :file "bidi/ring.cljc", :line 16, :type :protocol, :members ({:name request, :arglists ([_ req match-context]), :doc "Handle a Ring request, but optionally utilize any context that was\ncollected in the process of matching the handler.", :type :var})} {:name wrap-middleware, :file "bidi/ring.cljc", :line 193, :arglists ([matched middleware]), :type :var} {:name WrapMiddleware, :file "bidi/ring.cljc", :line 185, :type :var})} {:name bidi.schema, :publics ({:name AlternatesSet, :file "bidi/schema.cljc", :line 31, :doc "\n", :type :var} {:name DeprecatedAlternates, :file "bidi/schema.cljc", :line 34, :doc "\n", :type :var} {:name GeneralGuard, :file "bidi/schema.cljc", :line 23, :type :var} {:name Matched, :file "bidi/schema.cljc", :line 49, :type :var} {:name MethodGuard, :file "bidi/schema.cljc", :line 20, :type :var} {:name Path, :file "bidi/schema.cljc", :line 9, :type :var} {:name Pattern, :file "bidi/schema.cljc", :line 38, :type :var} {:name PatternSegment, :file "bidi/schema.cljc", :line 14, :type :var} {:name RoutePair, :file "bidi/schema.cljc", :line 59, :type :var} {:name SegmentedPattern, :file "bidi/schema.cljc", :line 26, :doc "\n", :type :var} {:name valid-qualifier-function?, :file "bidi/schema.cljc", :line 11, :arglists ([qual]), :type :var})} {:name bidi.verbose, :publics ({:name branch, :file "bidi/verbose.cljc", :line 8, :arglists ([fragment & children]), :type :var} {:name leaf, :file "bidi/verbose.cljc", :line 5, :arglists ([fragment name]), :type :var} {:name param, :file "bidi/verbose.cljc", :line 14, :arglists ([name]), :type :var})} {:name bidi.vhosts, :publics ({:name coerce-to-vhost, :file "bidi/vhosts.clj", :line 27, :type :var} {:name coerce-to-vhosts, :file "bidi/vhosts.clj", :line 38, :type :var} {:name find-handler, :file "bidi/vhosts.clj", :line 157, :arglists ([vhosts-model req]), :type :var} {:name host, :file "bidi/vhosts.clj", :line 94, :arglists ([req]), :doc "Get the real host from a request, taking into account reverse-proxy headers\n", :type :var} {:name host-for, :file "bidi/vhosts.clj", :line 149, :type :var} {:name href-for, :file "bidi/vhosts.clj", :line 151, :type :var} {:name make-default-not-found-handler, :file "bidi/vhosts.clj", :line 185, :arglists ([vhosts-model]), :type :var} {:name make-handler, :file "bidi/vhosts.clj", :line 193, :arglists ([vhosts-model] [vhosts-model handler-fn] [vhosts-model handler-fn not-found]), :type :var} {:name path-for, :file "bidi/vhosts.clj", :line 148, :type :var} {:name prioritize-vhosts, :file "bidi/vhosts.clj", :line 100, :arglists ([vhosts-model vhost]), :type :var} {:name Redirect, :file "bidi/vhosts.clj", :line 210, :type :var} {:name redirect, :file "bidi/vhosts.clj", :line 234, :arglists ([target & [opts]]), :type :var} {:name relativize, :file "bidi/vhosts.clj", :line 75, :arglists ([from to]), :type :var} {:name scheme, :file "bidi/vhosts.clj", :line 87, :arglists ([req]), :doc "Get the real scheme (as a keyword) from a request, taking into\naccount reverse-proxy headers", :type :var} {:name scheme-for, :file "bidi/vhosts.clj", :line 150, :type :var} {:name uri->host, :file "bidi/vhosts.clj", :line 22, :arglists ([uri]), :type :var} {:name uri-for, :file "bidi/vhosts.clj", :line 155, :deprecated true, :type :var} {:name uri-info, :file "bidi/vhosts.clj", :line 104, :arglists ([prioritized-vhosts handler & [{:keys [request vhost route-params query-params prefer fragment], :or {prefer :local}, :as options}]]), :doc "Return URI info as a map.\n", :type :var} {:name VHost, :file "bidi/vhosts.clj", :line 13, :doc "\n", :type :var} {:name vhosts->roots, :file "bidi/vhosts.clj", :line 175, :arglists ([vhosts request]), :type :var} {:name vhosts-model, :file "bidi/vhosts.clj", :line 53, :arglists ([& vhosts-with-routes]), :type :var} {:name VHostsModel, :file "bidi/vhosts.clj", :line 51, :type :var} {:name VHostWithRoutes, :file "bidi/vhosts.clj", :line 18, :doc "\n", :type :var})}), "cljs" ({:name bidi.bidi, :publics ({:name Alternates, :file "bidi/bidi.cljc", :line 481, :type :var} {:name alts, :file "bidi/bidi.cljc", :line 492, :arglists ([& alts]), :type :var} {:name compile-route, :file "bidi/bidi.cljc", :line 562, :arglists ([route]), :deprecated true, :type :var} {:name handler, :file "bidi/bidi.cljc", :line 521, :arglists ([k handler] [handler]), :deprecated true, :type :var} {:name IdentifiableHandler, :file "bidi/bidi.cljc", :line 512, :type :var} {:name just-path, :file "bidi/bidi.cljc", :line 187, :arglists ([path]), :type :var} {:name match-beginning, :file "bidi/bidi.cljc", :line 203, :arglists ([regex-pattern env]), :doc "Match the beginning of the :remainder value in m. If matched, update\nthe :remainder value in m with the path that remains after matching.", :type :var} {:name match-pair, :file "bidi/bidi.cljc", :line 194, :arglists ([[pattern matched] orig-env]), :doc "A pair contains a pattern to match (either fully or partially) and an\nexpression yielding a handler. The second parameter is a map\ncontaining state, including the remaining path.", :type :var} {:name match-route, :file "bidi/bidi.cljc", :line 385, :arglists ([route path & {:as options}]), :doc "Given a route definition data structure and a path, return the\nhandler, if any, that matches the path.", :type :var} {:name match-route*, :file "bidi/bidi.cljc", :line 380, :arglists ([route path options]), :type :var} {:name Matched, :file "bidi/bidi.cljc", :line 183, :type :protocol, :members ({:name resolve-handler, :arglists ([_ m]), :type :var} {:name unresolve-handler, :arglists ([_ m]), :type :var})} {:name Matches, :file "bidi/bidi.cljc", :line 404, :type :protocol, :members ({:name matches, :arglists ([_]), :doc "A protocol used in the expansion of possible matches that the pattern can match. This is used to gather all possible routes using route-seq below.\n", :type :var})} {:name ParameterEncoding, :file "bidi/bidi.cljc", :line 34, :type :protocol, :members ({:name encode-parameter, :arglists ([_]), :type :var})} {:name path-for, :file "bidi/bidi.cljc", :line 391, :arglists ([route handler & {:as params}]), :doc "Given a route definition data structure, a handler and an option map, return a\npath that would route to the handler. The map must contain the values to any\nparameters required to create the path, and extra values are silently ignored.", :type :var} {:name Pattern, :file "bidi/bidi.cljc", :line 176, :type :protocol, :members ({:name match-pattern, :arglists ([_ env]), :doc "Return a new state if this pattern matches the given state, or\nfalsy otherwise. If a new state is returned it will usually have the\nrest of the path to match in the :remainder entry.", :type :var} {:name unmatch-pattern, :arglists ([_ m]), :type :var})} {:name PatternSegment, :file "bidi/bidi.cljc", :line 71, :type :protocol, :members ({:name matches?, :arglists ([_ s]), :type :var} {:name param-key, :arglists ([_]), :type :var} {:name segment-regex-group, :arglists ([_]), :type :var} {:name transform-param, :arglists ([_]), :type :var} {:name unmatch-segment, :arglists ([_ params]), :type :var})} {:name Route, :file "bidi/bidi.cljc", :line 419, :type :var} {:name route-seq, :file "bidi/bidi.cljc", :line 424, :arglists ([[pattern matched] ctx] [route]), :type :var} {:name RouteProvider, :file "bidi/bidi.cljc", :line 465, :type :protocol, :members ({:name routes, :arglists ([_]), :doc "Provide a bidi route structure. Returns a vector pair,\nthe first element is the pattern, the second element is the matched\nroute or routes.", :type :var})} {:name routes-context, :file "bidi/bidi.cljc", :line 546, :arglists ([routes context]), :doc "Wrap a Matched such that a successful match will merge the given\ncontext with the match-context. The merge is such that where there\nis a conflict, the inner sub-tree overrides the outer container.", :type :var} {:name RoutesContext, :file "bidi/bidi.cljc", :line 533, :type :var} {:name RouteSeq, :file "bidi/bidi.cljc", :line 421, :type :protocol, :members ({:name gather, :arglists ([_ context]), :doc "Return a sequence of leaves\n", :type :var})} {:name succeed, :file "bidi/bidi.cljc", :line 211, :arglists ([handler m]), :type :var} {:name tag, :file "bidi/bidi.cljc", :line 509, :arglists ([matched tag]), :type :var} {:name TaggedMatch, :file "bidi/bidi.cljc", :line 498, :type :var} {:name unmatch-pair, :file "bidi/bidi.cljc", :line 324, :arglists ([v m]), :type :var} {:name url-decode, :file "bidi/bidi.cljc", :line 16, :arglists ([string]), :type :var} {:name url-encode, :file "bidi/bidi.cljc", :line 8, :arglists ([string]), :type :var} {:name uuid, :file "bidi/bidi.cljc", :line 22, :arglists ([s]), :doc "Function for creating a UUID of the appropriate type for the platform.\nNote that this function should _only_ be used in route patterns as, at least\nin the case of ClojureScript, it does not validate that the input string is\nactually a valid UUID (this is handled by the route matching logic).", :type :var})} {:name bidi.ring, :publics ({:name make-handler, :file "bidi/ring.cljc", :line 32, :arglists ([route handler-fn] [route]), :doc "Create a Ring handler from the route definition data\nstructure. Matches a handler from the uri in the request, and invokes\nit with the request as a parameter.", :type :var} {:name Ring, :file "bidi/ring.cljc", :line 16, :type :protocol, :members ({:name request, :arglists ([_ req match-context]), :doc "Handle a Ring request, but optionally utilize any context that was\ncollected in the process of matching the handler.", :type :var})})} {:name bidi.router, :publics ({:name Router, :file "bidi/router.cljs", :line 8, :type :protocol, :members ({:name replace-location!, :arglists ([_ location]), :type :var} {:name set-location!, :arglists ([_ location]), :type :var})} {:name start-router!, :file "bidi/router.cljs", :line 12, :arglists ([routes {:keys [on-navigate default-location], :or {on-navigate (constantly nil)}}]), :doc "Starts up a Bidi router based on Google Closure's 'History'\n\nTypes:\n\n  Location :- {:handler ...\n               :route-params {...}}\n\nParameters:\n\n  routes :- a Bidi route structure\n  on-navigate :- 0-arg function, accepting a Location\n  default-location :- Location to default to if the current token doesn't match a route\n\nReturns :- Router\n\nExample usage:\n\n  (require '[bidi.router :as br])\n\n  (let [!location (atom nil)\n        router (br/start-router! [\"\" {\"/\" ::home-page\n                                        \"/page2\" ::page2}]\n                                 {:on-navigate (fn [location]\n                                                 (reset! !location location))\n                                  :default-location {:handler ::home-page}})]\n\n    ...\n\n    (br/set-location! router {:handler ::page2}))", :type :var})} {:name bidi.schema, :publics ({:name AlternatesSet, :file "bidi/schema.cljc", :line 31, :doc "\n", :type :var} {:name DeprecatedAlternates, :file "bidi/schema.cljc", :line 34, :doc "\n", :type :var} {:name GeneralGuard, :file "bidi/schema.cljc", :line 23, :type :var} {:name Matched, :file "bidi/schema.cljc", :line 49, :type :var} {:name MethodGuard, :file "bidi/schema.cljc", :line 20, :type :var} {:name Path, :file "bidi/schema.cljc", :line 9, :type :var} {:name Pattern, :file "bidi/schema.cljc", :line 38, :type :var} {:name PatternSegment, :file "bidi/schema.cljc", :line 14, :type :var} {:name RoutePair, :file "bidi/schema.cljc", :line 59, :type :var} {:name SegmentedPattern, :file "bidi/schema.cljc", :line 26, :doc "\n", :type :var} {:name valid-qualifier-function?, :file "bidi/schema.cljc", :line 11, :arglists ([qual]), :type :var})} {:name bidi.verbose, :publics ({:name branch, :file "bidi/verbose.cljc", :line 8, :arglists ([fragment & children]), :type :var} {:name leaf, :file "bidi/verbose.cljc", :line 5, :arglists ([fragment name]), :type :var} {:name param, :file "bidi/verbose.cljc", :line 14, :arglists ([name]), :type :var})})}, :pom-str "<?xml version=\"1.0\" encoding=\"UTF-8\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>bidi</groupId>\n  <artifactId>bidi</artifactId>\n  <packaging>jar</packaging>\n  <version>2.1.3</version>\n  <name>bidi</name>\n  <description>Bidirectional URI routing</description>\n  <url>https://github.com/juxt/bidi</url>\n  <licenses>\n    <license>\n      <name>The MIT License</name>\n      <url>http://opensource.org/licenses/MIT</url>\n    </license>\n  </licenses>\n  <scm>\n    <url>https://github.com/juxt/bidi</url>\n    <connection>scm:git:git://github.com/juxt/bidi.git</connection>\n    <developerConnection>scm:git:ssh://git@github.com/juxt/bidi.git</developerConnection>\n    <tag>d1bfcc9c4fe247b8ada19cd7ee25acd81dd93f26</tag>\n  </scm>\n  <build>\n    <sourceDirectory>src</sourceDirectory>\n    <testSourceDirectory>test</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>test-resources</directory>\n      </testResource>\n      <testResource>\n        <directory>resources</directory>\n      </testResource>\n    </testResources>\n    <directory>target</directory>\n    <outputDirectory>target/classes</outputDirectory>\n    <plugins/>\n  </build>\n  <repositories>\n    <repository>\n      <id>central</id>\n      <url>https://repo1.maven.org/maven2/</url>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n    <repository>\n      <id>clojars</id>\n      <url>https://repo.clojars.org/</url>\n      <snapshots>\n        <enabled>true</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n  </repositories>\n  <dependencyManagement>\n    <dependencies/>\n  </dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>prismatic</groupId>\n      <artifactId>schema</artifactId>\n      <version>1.1.3</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n    </dependency>\n    <dependency>\n      <groupId>ring</groupId>\n      <artifactId>ring-core</artifactId>\n      <version>1.5.0</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n        <exclusion>\n          <artifactId>clojure</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojure</artifactId>\n      <version>1.8.0</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojurescript</artifactId>\n      <version>1.9.293</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>tools.reader</artifactId>\n      <version>1.0.0-beta4</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>ring</groupId>\n      <artifactId>ring-mock</artifactId>\n      <version>0.3.0</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>compojure</groupId>\n      <artifactId>compojure</artifactId>\n      <version>1.6.0-beta2</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>criterium</groupId>\n      <artifactId>criterium</artifactId>\n      <version>0.4.3</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.mozilla</groupId>\n      <artifactId>rhino</artifactId>\n      <version>1.7.7.1</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>tools.reader</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n<!-- This file was autogenerated by Leiningen.\n  Please do not edit it directly; instead edit project.clj and regenerate it.\n  It should not be considered canonical data. For more information see\n  https://github.com/technomancy/leiningen -->\n"}