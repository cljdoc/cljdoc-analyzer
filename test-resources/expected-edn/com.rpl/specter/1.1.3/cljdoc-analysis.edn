{:group-id "com.rpl", :artifact-id "specter", :version "1.1.3", :analysis {"clj" ({:name com.rpl.specter, :publics ({:name AFTER-ELEM, :file "com/rpl/specter.cljc", :line 834, :doc "Navigate to 'void' element after the sequence.\nFor transformations – if result is not `NONE`,\nthen append that value.", :type :var} {:name ALL, :file "com/rpl/specter.cljc", :line 679, :doc "Navigate to every element of the collection. For maps navigates to\na vector of `[key value]`.", :type :var} {:name ALL-WITH-META, :file "com/rpl/specter.cljc", :line 689, :doc "Same as ALL, except maintains metadata on the structure.\n", :type :var} {:name ATOM, :file "com/rpl/specter.cljc", :line 1085, :doc "Navigates to atom value.\n", :type :var} {:name BEFORE-ELEM, :file "com/rpl/specter.cljc", :line 819, :doc "Navigate to 'void' element before the sequence.\nFor transformations – if result is not `NONE`,\nthen prepend that value.", :type :var} {:name before-index, :file "com/rpl/specter.cljc", :line 968, :doc "Navigates to the empty space between the index and the prior index. For select\nnavigates to NONE, and transforms to non-NONE insert at that position.", :type :var} {:name BEGINNING, :file "com/rpl/specter.cljc", :line 777, :doc "Navigate to the empty subsequence before the first element of the collection.\n", :type :var} {:name codewalker, :file "com/rpl/specter.cljc", :line 1455, :doc "Like `walker` but maintains metadata of any forms traversed.\n", :type :var} {:name collect, :file "com/rpl/specter.cljc", :line 1292, :doc "Adds the result of running select with the given path on the\ncurrent value to the collected vals.", :type :var} {:name collect-one, :file "com/rpl/specter.cljc", :line 1302, :doc "Adds the result of running select-one with the given path on the\ncurrent value to the collected vals.", :type :var} {:name collected?, :file "com/rpl/specter.cljc", :line 399, :arglists ([params & body]), :doc "Creates a filter function navigator that takes in all the collected values\nas input. For arguments, can use `(collected? [a b] ...)` syntax to look\nat each collected value as individual arguments, or `(collected? v ...)` syntax\nto capture all the collected values as a single vector.", :type :macro} {:name collector, :file "com/rpl/specter.cljc", :line 67, :arglists ([params [_ [_ structure-sym] & body]]), :type :macro} {:name comp-paths, :file "com/rpl/specter.cljc", :line 478, :arglists ([& apath]), :doc "Returns a compiled version of the given path for use with\ncompiled-{select/transform/setval/etc.} functions.", :type :var} {:name compact, :file "com/rpl/specter.cljc", :line 1465, :doc "During transforms, after each step of navigation in subpath check if the\nvalue is empty. If so, remove that value by setting it to NONE.", :type :var} {:name compiled-multi-transform, :file "com/rpl/specter.cljc", :line 575, :doc "Version of `multi-transform` that takes in a path precompiled with `comp-paths`\n", :type :var} {:name compiled-replace-in, :file "com/rpl/specter.cljc", :line 596, :doc "Version of replace-in that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-select, :file "com/rpl/specter.cljc", :line 486, :doc "Version of select that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-select-any, :file "com/rpl/specter.cljc", :line 520, :doc "Version of select-any that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-select-first, :file "com/rpl/specter.cljc", :line 511, :doc "Version of select-first that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-select-one, :file "com/rpl/specter.cljc", :line 495, :doc "Version of select-one that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-select-one!, :file "com/rpl/specter.cljc", :line 503, :doc "Version of select-one! that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-selected-any?, :file "com/rpl/specter.cljc", :line 533, :doc "Version of selected-any? that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-setval, :file "com/rpl/specter.cljc", :line 588, :doc "Version of setval that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-transform, :file "com/rpl/specter.cljc", :line 562, :doc "Version of transform that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-traverse, :file "com/rpl/specter.cljc", :line 543, :doc "Version of traverse that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-traverse-all, :file "com/rpl/specter.cljc", :line 552, :doc "Version of traverse-all that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-vtransform, :file "com/rpl/specter.cljc", :line 565, :doc "Version of vtransform that takes in a path precompiled with comp-paths\n", :type :var} {:name cond-path, :file "com/rpl/specter.cljc", :line 1394, :doc "Takes in alternating cond-path path cond-path path...\nTests the structure if selecting with cond-path returns anything.\nIf so, it uses the following path for this portion of the navigation.\nOtherwise, it tries the next cond-path. If nothing matches, then the structure\nis not selected.", :type :var} {:name continue-then-stay, :file "com/rpl/specter.cljc", :line 1439, :doc "Navigates to the provided path and then to the current element. This can be used\nto implement post-order traversal.", :type :var} {:name continuous-subseqs, :file "com/rpl/specter.cljc", :line 766, :doc "Navigates to every continuous subsequence of elements matching `pred`\n", :type :var} {:name declarepath, :file "com/rpl/specter.cljc", :line 101, :arglists ([name]), :type :macro} {:name defcollector, :file "com/rpl/specter.cljc", :line 74, :arglists ([name & body]), :type :macro} {:name defdynamicnav, :file "com/rpl/specter.cljc", :line 147, :arglists ([name & args]), :doc "Defines a function that can choose what navigator to use at runtime based on\nthe dynamic context. The arguments will either be static values or\nobjects satisfying `dynamic-param?`. Use `late-bound-nav` to produce a runtime\nnavigator that uses the values of the dynamic params. See `selected?` for\nan illustrative example of dynamic navs.", :type :macro} {:name defmacroalias, :file "com/rpl/specter.cljc", :line 57, :arglists ([name target]), :type :macro} {:name defnav, :file "com/rpl/specter.cljc", :line 64, :type :macro} {:name defprotocolpath, :file "com/rpl/specter.cljc", :line 415, :arglists ([name] [name params]), :doc "Defines a navigator that chooses the path to take based on the type\nof the value at the current point. May be specified with parameters to\nspecify that all extensions must require that number of parameters.\n\nCurrently not available for ClojureScript.\n\nExample of usage:\n(defrecord SingleAccount [funds])\n(defrecord FamilyAccount [single-accounts])\n\n(defprotocolpath FundsPath)\n(extend-protocolpath FundsPath\n  SingleAccount :funds\n  FamilyAccount [ALL FundsPath]\n  )\n", :type :macro} {:name defrichnav, :file "com/rpl/specter.cljc", :line 65, :type :macro} {:name DISPENSE, :file "com/rpl/specter.cljc", :line 1340, :doc "Drops all collected values for subsequent navigation.\n", :type :var} {:name dynamic-param?, :file "com/rpl/specter.cljc", :line 611, :type :var} {:name dynamicnav, :file "com/rpl/specter.cljc", :line 144, :arglists ([& args]), :type :macro} {:name eachnav, :file "com/rpl/specter.cljc", :line 615, :doc "Turns a navigator that takes one argument into a navigator that takes\nmany arguments and uses the same navigator with each argument. There\nis no performance cost to using this. See implementation of `keypath`", :type :var} {:name END, :file "com/rpl/specter.cljc", :line 790, :doc "Navigate to the empty subsequence after the last element of the collection.\n", :type :var} {:name end-fn, :file "com/rpl/specter.cljc", :line 471, :arglists ([& args]), :type :macro} {:name extend-protocolpath, :file "com/rpl/specter.cljc", :line 462, :arglists ([protpath & extensions]), :doc "Used in conjunction with `defprotocolpath`. See [[defprotocolpath]].\n", :type :macro} {:name extend-protocolpath*, :file "com/rpl/specter.cljc", :line 454, :arglists ([protpath-prot extensions]), :type :var} {:name filterer, :file "com/rpl/specter.cljc", :line 1141, :doc "Navigates to a view of the current sequence that only contains elements that\nmatch the given path. An element matches the selector path if calling select\non that element with the path yields anything other than an empty sequence.\n\nFor transformation: `NONE` entries in the result sequence cause corresponding entries in\ninput to be removed. A result sequence smaller than the input sequence is equivalent to\npadding the result sequence with `NONE` at the end until the same size as the input.", :type :var} {:name FIRST, :file "com/rpl/specter.cljc", :line 735, :doc "Navigate to the first element of the collection. If the collection is\nempty navigation is stopped at this point.", :type :var} {:name if-path, :file "com/rpl/specter.cljc", :line 1349, :doc "Like cond-path, but with if semantics.\n", :type :var} {:name index-nav, :file "com/rpl/specter.cljc", :line 983, :doc "Navigates to the index of the sequence if within 0 and size. Transforms move element\nat that index to the new index, shifting other elements in the sequence.", :type :var} {:name INDEXED-VALS, :file "com/rpl/specter.cljc", :line 1058, :doc "`indexed-vals` with a starting index of 0.\n", :type :var} {:name indexed-vals, :file "com/rpl/specter.cljc", :line 1022, :doc "Navigate to [index elem] pairs for each element in a sequence. The sequence will be indexed\nstarting from `start`. Changing index in transform has same effect as `index-nav`. Indices seen\nduring transform take into account any shifting from prior sequence elements changing indices.", :type :var} {:name keypath, :file "com/rpl/specter.cljc", :line 952, :doc "Navigate to the specified keys one after another. If navigate to NONE,\nthat element is removed from the map or vector.", :type :var} {:name LAST, :file "com/rpl/specter.cljc", :line 729, :doc "Navigate to the last element of the collection. If the collection is\nempty navigation is stopped at this point.", :type :var} {:name late-bound-collector, :file "com/rpl/specter.cljc", :line 91, :arglists ([bindings impl]), :type :macro} {:name late-bound-nav, :file "com/rpl/specter.cljc", :line 88, :arglists ([bindings & impls]), :type :macro} {:name late-bound-richnav, :file "com/rpl/specter.cljc", :line 94, :arglists ([bindings & impls]), :type :macro} {:name late-path, :file "com/rpl/specter.cljc", :line 610, :type :var} {:name late-resolved-fn, :file "com/rpl/specter.cljc", :line 612, :type :var} {:name local-declarepath, :file "com/rpl/specter.cljc", :line 628, :type :var} {:name map-key, :file "com/rpl/specter.cljc", :line 909, :doc "Navigates to the given key in the map (not to the value). Navigates only if the\nkey currently exists in the map. Can transform to NONE to remove the key/value\npair from the map.", :type :var} {:name MAP-KEYS, :file "com/rpl/specter.cljc", :line 713, :doc "Navigate to each key of the map. This is more efficient than\nnavigating via [ALL FIRST]", :type :var} {:name MAP-VALS, :file "com/rpl/specter.cljc", :line 702, :doc "Navigate to each value of the map. This is more efficient than\nnavigating via [ALL LAST]", :type :var} {:name META, :file "com/rpl/specter.cljc", :line 1257, :doc "Navigates to the metadata of the structure, or nil if\nthe structure has no metadata or may not contain metadata.", :type :var} {:name multi-path, :file "com/rpl/specter.cljc", :line 1409, :doc "A path that branches on multiple paths. For updates,\napplies updates to the paths in order.", :type :var} {:name multi-transform, :file "com/rpl/specter.cljc", :line 361, :arglists ([apath structure]), :doc "Just like `transform` but expects transform functions to be specified\ninline in the path using `terminal` or `vterminal`. Error is thrown if navigation finishes\nat a non-terminal navigator. `terminal-val` is a wrapper around `terminal` and is\nthe `multi-transform` equivalent of `setval`.\nThis macro will do inline caching of the path.", :type :macro} {:name multi-transform*, :file "com/rpl/specter.cljc", :line 579, :arglists ([path structure]), :doc "Just like `transform` but expects transform functions to be specified\ninline in the path using `terminal` or `vterminal`. Error is thrown if navigation finishes\nat a non-terminal navigator. `terminal-val` is a wrapper around `terminal` and is\nthe `multi-transform` equivalent of `setval`.", :type :var} {:name must, :file "com/rpl/specter.cljc", :line 957, :doc "Navigate to the specified keys one after another, only if they exist\nin the data structure. If navigate to NONE, that element is removed\nfrom the map or vector.", :type :var} {:name NAME, :file "com/rpl/specter.cljc", :line 1266, :doc "Navigates to the name portion of the keyword or symbol\n", :type :var} {:name NAMESPACE, :file "com/rpl/specter.cljc", :line 1279, :doc "Navigates to the namespace portion of the keyword or symbol\n", :type :var} {:name nav, :file "com/rpl/specter.cljc", :line 63, :type :macro} {:name NIL->LIST, :file "com/rpl/specter.cljc", :line 1245, :doc "Navigates to '() if the value is nil. Otherwise it stays\nnavigated at the current value.", :type :var} {:name NIL->SET, :file "com/rpl/specter.cljc", :line 1239, :doc "Navigates to #{} if the value is nil. Otherwise it stays\nnavigated at the current value.", :type :var} {:name nil->val, :file "com/rpl/specter.cljc", :line 1229, :doc "Navigates to the provided val if the structure is nil. Otherwise it stays\nnavigated at the structure.", :type :var} {:name NIL->VECTOR, :file "com/rpl/specter.cljc", :line 1251, :doc "Navigates to [] if the value is nil. Otherwise it stays\nnavigated at the current value.", :type :var} {:name NONE, :file "com/rpl/specter.cljc", :line 523, :doc "Global value used to indicate no elements selected during\n[[select-any]].", :type :var} {:name NONE-ELEM, :file "com/rpl/specter.cljc", :line 802, :doc "Navigate to 'void' elem in the set.\nFor transformations - if result is not `NONE`,\nthen add that value to the set.", :type :var} {:name not-selected?, :file "com/rpl/specter.cljc", :line 1124, :type :var} {:name nthpath, :file "com/rpl/specter.cljc", :line 963, :doc "Navigate to the specified indices one after another. If navigate to\nNONE, that element is removed from the sequence.", :type :var} {:name parser, :file "com/rpl/specter.cljc", :line 1073, :doc "Navigate to the result of running `parse-fn` on the value. For\ntransforms, the transformed value then has `unparse-fn` run on\nit to get the final value at this point.", :type :var} {:name path, :file "com/rpl/specter.cljc", :line 232, :arglists ([& path]), :doc "Same as calling comp-paths, except it caches the composition of the static parts\nof the path for later re-use (when possible). For almost all idiomatic uses\nof Specter provides huge speedup. This macro is automatically used by the\nselect/transform/setval/replace-in/etc. macros.", :type :macro} {:name pred, :file "com/rpl/specter.cljc", :line 1175, :doc "Keeps the element only if it matches the supplied predicate. Functions in paths\nimplicitly convert to this navigator.", :type :var} {:name pred<, :file "com/rpl/specter.cljc", :line 1184, :arglists ([v]), :type :var} {:name pred<=, :file "com/rpl/specter.cljc", :line 1186, :arglists ([v]), :type :var} {:name pred=, :file "com/rpl/specter.cljc", :line 1183, :arglists ([v]), :type :var} {:name pred>, :file "com/rpl/specter.cljc", :line 1185, :arglists ([v]), :type :var} {:name pred>=, :file "com/rpl/specter.cljc", :line 1187, :arglists ([v]), :type :var} {:name providepath, :file "com/rpl/specter.cljc", :line 104, :arglists ([name apath]), :type :macro} {:name putval, :file "com/rpl/specter.cljc", :line 1312, :doc "Adds an external value to the collected vals. Useful when additional arguments\nare required to the transform function that would otherwise require partial\napplication or a wrapper function.\n\ne.g., incrementing val at path [:a :b] by 3:\n(transform [:a :b (putval 3)] + some-map)", :type :var} {:name recursive-path, :file "com/rpl/specter.cljc", :line 107, :arglists ([params self-sym path]), :type :macro} {:name regex-nav, :file "com/rpl/specter.cljc", :line 1096, :type :var} {:name replace-in, :file "com/rpl/specter.cljc", :line 389, :arglists ([apath transform-fn structure & args]), :doc "Similar to transform, except returns a pair of [transformed-structure sequence-of-user-ret].\nThe transform-fn in this case is expected to return [ret user-ret]. ret is\nwhat's used to transform the data structure, while user-ret will be added to the user-ret sequence\nin the final return. replace-in is useful for situations where you need to know the specific values\nof what was transformed in the data structure.\nThis macro will do inline caching of the path.", :type :macro} {:name replace-in*, :file "com/rpl/specter.cljc", :line 599, :arglists ([path transform-fn structure & {:keys [merge-fn], :or {merge-fn concat}}]), :doc "Similar to transform, except returns a pair of [transformed-structure sequence-of-user-ret].\nThe transform-fn in this case is expected to return [ret user-ret]. ret is\nwhat's used to transform the data structure, while user-ret will be added to the user-ret sequence\nin the final return. replace-in is useful for situations where you need to know the specific values\nof what was transformed in the data structure.", :type :var} {:name richnav, :file "com/rpl/specter.cljc", :line 62, :type :macro} {:name satisfies-protpath?, :file "com/rpl/specter.cljc", :line 451, :arglists ([protpath o]), :type :macro} {:name select, :file "com/rpl/specter.cljc", :line 311, :arglists ([apath structure]), :doc "Navigates to and returns a sequence of all the elements specified by the path.\nThis macro will do inline caching of the path.", :type :macro} {:name select*, :file "com/rpl/specter.cljc", :line 489, :arglists ([path structure]), :doc "Navigates to and returns a sequence of all the elements specified by the path.\n", :type :var} {:name select-any, :file "com/rpl/specter.cljc", :line 335, :arglists ([apath structure]), :doc "Returns any element found or [[NONE]] if nothing selected. This is the most\nefficient of the various selection operations.\nThis macro will do inline caching of the path.", :type :macro} {:name select-any*, :file "com/rpl/specter.cljc", :line 527, :arglists ([path structure]), :doc "Returns any element found or [[NONE]] if nothing selected. This is the most\nefficient of the various selection operations.", :type :var} {:name select-first, :file "com/rpl/specter.cljc", :line 329, :arglists ([apath structure]), :doc "Returns first element found.\nThis macro will do inline caching of the path.", :type :macro} {:name select-first*, :file "com/rpl/specter.cljc", :line 515, :arglists ([path structure]), :doc "Returns first element found.\n", :type :var} {:name select-one, :file "com/rpl/specter.cljc", :line 323, :arglists ([apath structure]), :doc "Like select, but returns either one element or nil. Throws exception if multiple elements found.\nThis macro will do inline caching of the path.", :type :macro} {:name select-one!, :file "com/rpl/specter.cljc", :line 317, :arglists ([apath structure]), :doc "Returns exactly one element, throws exception if zero or multiple elements found.\nThis macro will do inline caching of the path.", :type :macro} {:name select-one!*, :file "com/rpl/specter.cljc", :line 506, :arglists ([path structure]), :doc "Returns exactly one element, throws exception if zero or multiple elements found\n", :type :var} {:name select-one*, :file "com/rpl/specter.cljc", :line 498, :arglists ([path structure]), :doc "Like select, but returns either one element or nil. Throws exception if multiple elements found\n", :type :var} {:name selected-any?, :file "com/rpl/specter.cljc", :line 342, :arglists ([apath structure]), :doc "Returns true if any element was selected, false otherwise.\nThis macro will do inline caching of the path.", :type :macro} {:name selected-any?*, :file "com/rpl/specter.cljc", :line 536, :arglists ([path structure]), :doc "Returns true if any element was selected, false otherwise.\n", :type :var} {:name selected?, :file "com/rpl/specter.cljc", :line 1103, :doc "Filters the current value based on whether a path finds anything.\ne.g. (selected? :vals ALL even?) keeps the current element only if an\neven number exists for the :vals key.", :type :var} {:name set-elem, :file "com/rpl/specter.cljc", :line 931, :doc "Navigates to the given element in the set only if it exists in the set.\nCan transform to NONE to remove the element from the set.", :type :var} {:name setval, :file "com/rpl/specter.cljc", :line 371, :arglists ([apath aval structure]), :doc "Navigates to each value specified by the path and replaces it by `aval`.\nThis macro will do inline caching of the path.", :type :macro} {:name setval*, :file "com/rpl/specter.cljc", :line 591, :arglists ([path val structure]), :doc "Navigates to each value specified by the path and replaces it by val\n", :type :var} {:name srange, :file "com/rpl/specter.cljc", :line 755, :doc "Navigates to the subsequence bound by the indexes start (inclusive)\nand end (exclusive)", :type :var} {:name srange-dynamic, :file "com/rpl/specter.cljc", :line 741, :doc "Uses start-index-fn and end-index-fn to determine the bounds of the subsequence\nto select when navigating. `start-index-fn` takes in the structure as input. `end-index-fn`\ncan be one of two forms. If a regular function (e.g. defined with `fn`), it takes in only the structure as input. If a function defined using special `end-fn` macro, it takes in the structure and the result of `start-index-fn`.", :type :var} {:name STAY, :file "com/rpl/specter.cljc", :line 644, :doc "Stays navigated at the current point. Essentially a no-op navigator.\n", :type :var} {:name stay-then-continue, :file "com/rpl/specter.cljc", :line 1433, :doc "Navigates to the current element and then navigates via the provided path.\nThis can be used to implement pre-order traversal.", :type :var} {:name STOP, :file "com/rpl/specter.cljc", :line 632, :doc "Stops navigation at this point. For selection returns nothing and for\ntransformation returns the structure unchanged", :type :var} {:name submap, :file "com/rpl/specter.cljc", :line 865, :doc "Navigates to the specified submap (using select-keys).\nIn a transform, that submap in the original map is changed to the new\nvalue of the submap.", :type :var} {:name subselect, :file "com/rpl/specter.cljc", :line 880, :doc "Navigates to a sequence that contains the results of (select ...),\nbut is a view to the original structure that can be transformed.\n\nRequires that the input navigators will walk the structure's\nchildren in the same order when executed on \"select\" and then\n\"transform\".\n\nIf transformed sequence is smaller than input sequence, missing entries\nwill be filled in with NONE, triggering removal if supported by that navigator.\n\nValue collection (e.g. collect, collect-one) may not be used in the subpath.", :type :var} {:name subset, :file "com/rpl/specter.cljc", :line 849, :doc "Navigates to the specified subset (by taking an intersection).\nIn a transform, that subset in the original set is changed to the\nnew value of the subset.", :type :var} {:name terminal, :file "com/rpl/specter.cljc", :line 649, :doc "Defines an endpoint in the navigation the transform function run. The transform\nfunction works just like it does in `transform`, with collected values\ngiven as the first arguments", :type :var} {:name terminal-val, :file "com/rpl/specter.cljc", :line 673, :arglists ([v]), :doc "Like `terminal` but specifies a val to set at the location regardless of\nthe collected values or the value at the location.", :type :var} {:name transform, :file "com/rpl/specter.cljc", :line 348, :arglists ([apath transform-fn structure]), :doc "Navigates to each value specified by the path and replaces it by the result of running\nthe transform-fn on it.\nThis macro will do inline caching of the path.", :type :macro} {:name transform*, :file "com/rpl/specter.cljc", :line 569, :arglists ([path transform-fn structure]), :doc "Navigates to each value specified by the path and replaces it by the result of running\nthe transform-fn on it", :type :var} {:name transformed, :file "com/rpl/specter.cljc", :line 1152, :doc "Navigates to a view of the current value by transforming it with the\nspecified path and update-fn.", :type :var} {:name traverse, :file "com/rpl/specter.cljc", :line 377, :arglists ([apath structure]), :doc "Return a reducible object that traverses over `structure` to every element\nspecified by the path.\nThis macro will do inline caching of the path.", :type :macro} {:name traverse*, :file "com/rpl/specter.cljc", :line 546, :arglists ([apath structure]), :doc "Return a reducible object that traverses over `structure` to every element\nspecified by the path", :type :var} {:name traverse-all, :file "com/rpl/specter.cljc", :line 384, :arglists ([apath]), :doc "Returns a transducer that traverses over each element with the given path.\n", :type :macro} {:name traverse-all*, :file "com/rpl/specter.cljc", :line 555, :arglists ([apath]), :doc "Returns a transducer that traverses over each element with the given path.\n", :type :var} {:name traversed, :file "com/rpl/specter.cljc", :line 1163, :doc "Navigates to a view of the current value by transforming with a reduction over\nthe specified traversal.", :type :var} {:name VAL, :file "com/rpl/specter.cljc", :line 725, :type :var} {:name view, :file "com/rpl/specter.cljc", :line 1063, :doc "Navigates to result of running `afn` on the currently navigated value.\n", :type :var} {:name vterminal, :file "com/rpl/specter.cljc", :line 660, :doc "Defines an endpoint in the navigation the transform function run.The transform\nfunction works differently than it does in `transform`. Rather than receive\ncollected vals spliced in as the first arguments to the function, this function\nalways takes two arguemnts. The first is all collected vals in a vector, and\nthe second is the navigated value.", :type :var} {:name vtransform, :file "com/rpl/specter.cljc", :line 355, :arglists ([apath transform-fn structure]), :doc "Navigates to each value specified by the path and replaces it by the result of running\nthe transform-fn on two arguments: the collected values as a vector, and the navigated value.", :type :macro} {:name walker, :file "com/rpl/specter.cljc", :line 1445, :doc "Navigate the data structure until reaching\na value for which `afn` returns truthy. Has\nsame semantics as clojure.walk.", :type :var} {:name with-fresh-collected, :file "com/rpl/specter.cljc", :line 1325, :doc "Continues navigating on the given path with the collected vals reset to []. Once\nnavigation leaves the scope of with-fresh-collected, the collected vals revert\nto what they were before.", :type :var} {:name with-inline-debug, :file "com/rpl/specter.cljc", :line 97, :arglists ([& body]), :type :macro} {:name wrap-dynamic-nav, :file "com/rpl/specter.cljc", :line 41, :arglists ([f]), :type :var})} {:name com.rpl.specter.impl, :publics ({:name *DEBUG-INLINE-CACHING*, :file "com/rpl/specter/impl.cljc", :line 902, :dynamic true, :type :var} {:name *path-compile-files*, :file "com/rpl/specter/impl.cljc", :line 911, :dynamic true, :type :var} {:name *tmp-closure*, :file "com/rpl/specter/impl.cljc", :line 620, :dynamic true, :type :var} {:name all-static?, :file "com/rpl/specter/impl.cljc", :line 689, :arglists ([params]), :type :var} {:name benchmark, :file "com/rpl/specter/impl.cljc", :line 109, :arglists ([iters afn]), :type :var} {:name cached-path-info-dynamic?, :file "com/rpl/specter/impl.cljc", :line 488, :arglists ([c]), :type :var} {:name cached-path-info-precompiled, :file "com/rpl/specter/impl.cljc", :line 485, :arglists ([c]), :type :var} {:name CachedPathInfo, :file "com/rpl/specter/impl.cljc", :line 478, :type :var} {:name cell-nav, :file "com/rpl/specter/impl.cljc", :line 524, :arglists ([cell]), :type :var} {:name clj-macroexpand-all, :file "com/rpl/specter/impl.cljc", :line 87, :arglists ([form]), :type :var} {:name cljs-analyzer-macroexpand-1, :file "com/rpl/specter/impl.cljc", :line 76, :arglists ([]), :type :var} {:name closed-code, :file "com/rpl/specter/impl.cljc", :line 621, :arglists ([closure body]), :type :var} {:name codewalk-until, :file "com/rpl/specter/impl.cljc", :line 590, :arglists ([pred on-match-fn structure]), :type :var} {:name coerce-nav, :file "com/rpl/specter/impl.cljc", :line 654, :arglists ([o]), :type :var} {:name CoercePath, :file "com/rpl/specter/impl.cljc", :line 158, :type :protocol, :members ({:name coerce-path, :arglists ([this]), :type :var})} {:name collected?*, :file "com/rpl/specter/impl.cljc", :line 513, :arglists ([afn]), :type :var} {:name combine-two-navs, :file "com/rpl/specter/impl.cljc", :line 197, :arglists ([nav1 nav2]), :type :var} {:name comp-navs, :file "com/rpl/specter/impl.cljc", :line 544, :arglists ([] [nav1__1045__auto__] [nav1__1045__auto__ nav2__1046__auto__] [G__1790 G__1791 G__1792] [G__1793 G__1794 G__1795 G__1796] [G__1797 G__1798 G__1799 G__1800 G__1801] [G__1802 G__1803 G__1804 G__1805 G__1806 G__1807] [G__1808 G__1809 G__1810 G__1811 G__1812 G__1813 G__1814] [G__1815 G__1816 G__1817 G__1818 G__1819 G__1820 G__1821 G__1822] [G__1823 G__1824 G__1825 G__1826 G__1827 G__1828 G__1829 G__1830 G__1831] [G__1832 G__1833 G__1834 G__1835 G__1836 G__1837 G__1838 G__1839 G__1840 G__1841] [G__1842 G__1843 G__1844 G__1845 G__1846 G__1847 G__1848 G__1849 G__1850 G__1851 G__1852] [G__1853 G__1854 G__1855 G__1856 G__1857 G__1858 G__1859 G__1860 G__1861 G__1862 G__1863 G__1864] [G__1865 G__1866 G__1867 G__1868 G__1869 G__1870 G__1871 G__1872 G__1873 G__1874 G__1875 G__1876 G__1877] [G__1878 G__1879 G__1880 G__1881 G__1882 G__1883 G__1884 G__1885 G__1886 G__1887 G__1888 G__1889 G__1890 G__1891] [G__1892 G__1893 G__1894 G__1895 G__1896 G__1897 G__1898 G__1899 G__1900 G__1901 G__1902 G__1903 G__1904 G__1905 G__1906] [G__1907 G__1908 G__1909 G__1910 G__1911 G__1912 G__1913 G__1914 G__1915 G__1916 G__1917 G__1918 G__1919 G__1920 G__1921 G__1922] [G__1923 G__1924 G__1925 G__1926 G__1927 G__1928 G__1929 G__1930 G__1931 G__1932 G__1933 G__1934 G__1935 G__1936 G__1937 G__1938 G__1939] [G__1940 G__1941 G__1942 G__1943 G__1944 G__1945 G__1946 G__1947 G__1948 G__1949 G__1950 G__1951 G__1952 G__1953 G__1954 G__1955 G__1956 G__1957] [G__1958 G__1959 G__1960 G__1961 G__1962 G__1963 G__1964 G__1965 G__1966 G__1967 G__1968 G__1969 G__1970 G__1971 G__1972 G__1973 G__1974 G__1975 G__1976] [G__1771 G__1772 G__1773 G__1774 G__1775 G__1776 G__1777 G__1778 G__1779 G__1780 G__1781 G__1782 G__1783 G__1784 G__1785 G__1786 G__1787 G__1788 G__1789 & rest__1047__auto__]), :type :var} {:name comp-paths*, :file "com/rpl/specter/impl.cljc", :line 149, :arglists ([p]), :type :var} {:name compiled-multi-transform*, :file "com/rpl/specter/impl.cljc", :line 992, :arglists ([path structure]), :type :var} {:name compiled-replace-in*, :file "com/rpl/specter/impl.cljc", :line 970, :arglists ([path transform-fn structure & {:keys [merge-fn], :or {merge-fn concat}}]), :type :var} {:name compiled-select*, :file "com/rpl/specter/impl.cljc", :line 364, :arglists ([path structure]), :type :var} {:name compiled-select-any*, :file "com/rpl/specter/impl.cljc", :line 403, :arglists ([path structure] [path vals structure]), :type :var} {:name compiled-select-first*, :file "com/rpl/specter/impl.cljc", :line 408, :arglists ([path structure]), :type :var} {:name compiled-select-one!*, :file "com/rpl/specter/impl.cljc", :line 388, :arglists ([path structure]), :type :var} {:name compiled-select-one*, :file "com/rpl/specter/impl.cljc", :line 373, :arglists ([path structure]), :type :var} {:name compiled-selected-any?*, :file "com/rpl/specter/impl.cljc", :line 415, :arglists ([path structure]), :type :var} {:name compiled-setval*, :file "com/rpl/specter/impl.cljc", :line 967, :arglists ([path val structure]), :type :var} {:name compiled-transform*, :file "com/rpl/specter/impl.cljc", :line 425, :arglists ([nav transform-fn structure]), :type :var} {:name compiled-traverse*, :file "com/rpl/specter/impl.cljc", :line 303, :arglists ([path result-fn structure]), :type :var} {:name compiled-traverse-all*, :file "com/rpl/specter/impl.cljc", :line 349, :arglists ([path]), :type :var} {:name compiled-traverse-with-vals*, :file "com/rpl/specter/impl.cljc", :line 281, :arglists ([path result-fn vals structure]), :type :macro} {:name compiled-vtransform*, :file "com/rpl/specter/impl.cljc", :line 430, :arglists ([nav transform-fn structure]), :type :var} {:name continuous-subseqs-transform*, :file "com/rpl/specter/impl.cljc", :line 583, :arglists ([pred structure next-fn]), :type :var} {:name direct-nav-obj, :file "com/rpl/specter/impl.cljc", :line 672, :arglists ([o]), :type :var} {:name direct-nav?, :file "com/rpl/specter/impl.cljc", :line 686, :arglists ([o]), :type :var} {:name do-compiled-traverse, :file "com/rpl/specter/impl.cljc", :line 337, :arglists ([apath structure]), :type :var} {:name do-compiled-traverse*, :file "com/rpl/specter/impl.cljc", :line 306, :arglists ([apath structure]), :type :var} {:name dynamic->code, :file "com/rpl/specter/impl.cljc", :line 834, :arglists ([o]), :type :var} {:name dynamic-fn-code, :file "com/rpl/specter/impl.cljc", :line 801, :arglists ([afn args]), :type :var} {:name dynamic-param?, :file "com/rpl/specter/impl.cljc", :line 463, :arglists ([o]), :type :var} {:name dynamic-val-code, :file "com/rpl/specter/impl.cljc", :line 809, :arglists ([code possible-params]), :type :var} {:name dynamic-var?, :file "com/rpl/specter/impl.cljc", :line 666, :arglists ([v]), :type :var} {:name DynamicFunction, :file "com/rpl/specter/impl.cljc", :line 460, :type :var} {:name DynamicPath, :file "com/rpl/specter/impl.cljc", :line 457, :type :var} {:name DynamicVal, :file "com/rpl/specter/impl.cljc", :line 454, :type :var} {:name eval+, :file "com/rpl/specter/impl.cljc", :line 640, :arglists ([form]), :doc "Automatically extracts non-evalable stuff into a closure and then evals\n", :type :var} {:name exec-select*, :file "com/rpl/specter/impl.cljc", :line 116, :arglists ([this & args]), :type :macro} {:name exec-transform*, :file "com/rpl/specter/impl.cljc", :line 130, :arglists ([this & args]), :type :macro} {:name fast-constantly, :file "com/rpl/specter/impl.cljc", :line 38, :arglists ([v]), :type :var} {:name fast-object-array, :file "com/rpl/specter/impl.cljc", :line 105, :arglists ([i]), :type :macro} {:name filter-select, :file "com/rpl/specter/impl.cljc", :line 492, :arglists ([afn vals structure next-fn]), :type :var} {:name filter-transform, :file "com/rpl/specter/impl.cljc", :line 497, :arglists ([afn vals structure next-fn]), :type :var} {:name fn-invocation?, :file "com/rpl/specter/impl.cljc", :line 433, :arglists ([f]), :type :var} {:name FnInvocation, :file "com/rpl/specter/impl.cljc", :line 450, :type :var} {:name get-cell, :file "com/rpl/specter/impl.cljc", :line 263, :arglists ([c]), :type :var} {:name intern*, :file "com/rpl/specter/impl.cljc", :line 97, :arglists ([ns name val]), :type :var} {:name late-path, :file "com/rpl/specter/impl.cljc", :line 471, :arglists ([path]), :type :var} {:name late-resolved-fn, :file "com/rpl/specter/impl.cljc", :line 692, :arglists ([afn]), :type :var} {:name local-declarepath, :file "com/rpl/specter/impl.cljc", :line 531, :arglists ([]), :type :var} {:name LocalSym, :file "com/rpl/specter/impl.cljc", :line 439, :type :var} {:name magic-precompilation, :file "com/rpl/specter/impl.cljc", :line 946, :arglists ([path ns-str used-locals-list possible-params]), :type :var} {:name matching-ranges, :file "com/rpl/specter/impl.cljc", :line 566, :arglists ([aseq p]), :type :var} {:name maybe-direct-nav, :file "com/rpl/specter/impl.cljc", :line 675, :arglists ([obj direct-nav?]), :type :var} {:name mk-dynamic-path-maker, :file "com/rpl/specter/impl.cljc", :line 914, :arglists ([resolved-code ns-str used-locals-list possible-param]), :type :var} {:name mutable-cell, :file "com/rpl/specter/impl.cljc", :line 241, :arglists ([] [v]), :type :var} {:name NONE, :file "com/rpl/specter/impl.cljc", :line 23, :type :var} {:name original-obj, :file "com/rpl/specter/impl.cljc", :line 680, :arglists ([o]), :type :var} {:name PathComposer, :file "com/rpl/specter/impl.cljc", :line 142, :type :protocol, :members ({:name do-comp-paths, :arglists ([paths]), :type :var})} {:name pred*, :file "com/rpl/specter/impl.cljc", :line 502, :arglists ([afn]), :type :var} {:name preserve-map, :file "com/rpl/specter/impl.cljc", :line 699, :arglists ([afn o]), :type :var} {:name providepath*, :file "com/rpl/specter/impl.cljc", :line 535, :arglists ([declared compiled-path]), :type :var} {:name resolve-arg-code, :file "com/rpl/specter/impl.cljc", :line 838, :arglists ([o possible-params]), :type :var} {:name resolve-nav-code, :file "com/rpl/specter/impl.cljc", :line 862, :arglists ([o possible-params]), :type :var} {:name rich-nav?, :file "com/rpl/specter/impl.cljc", :line 145, :arglists ([n]), :type :var} {:name set-cell!, :file "com/rpl/specter/impl.cljc", :line 253, :arglists ([c v]), :type :var} {:name smart-str, :file "com/rpl/specter/impl.cljc", :line 35, :arglists ([& elems]), :type :var} {:name SpecialFormUse, :file "com/rpl/specter/impl.cljc", :line 447, :type :var} {:name spy, :file "com/rpl/specter/impl.cljc", :line 25, :arglists ([e]), :type :var} {:name srange-transform*, :file "com/rpl/specter/impl.cljc", :line 546, :arglists ([structure start end next-fn]), :type :var} {:name static-combine, :file "com/rpl/specter/impl.cljc", :line 740, :arglists ([o] [o nav-pos?]), :type :var} {:name static-fn-code, :file "com/rpl/specter/impl.cljc", :line 793, :arglists ([afn args]), :type :var} {:name static-path?, :file "com/rpl/specter/impl.cljc", :line 466, :arglists ([path]), :type :var} {:name static-val-code, :file "com/rpl/specter/impl.cljc", :line 822, :arglists ([o]), :type :var} {:name STAY*, :file "com/rpl/specter/impl.cljc", :line 190, :type :var} {:name terminal*, :file "com/rpl/specter/impl.cljc", :line 418, :arglists ([afn vals structure]), :type :var} {:name throw*, :file "com/rpl/specter/impl.cljc", :line 54, :arglists ([etype & args]), :type :macro} {:name throw-illegal, :file "com/rpl/specter/impl.cljc", :line 59, :arglists ([& args]), :type :macro} {:name update-cell!, :file "com/rpl/specter/impl.cljc", :line 274, :arglists ([cell afn]), :type :var} {:name used-locals, :file "com/rpl/specter/impl.cljc", :line 892, :arglists ([locals-set form]), :type :var} {:name VarUse, :file "com/rpl/specter/impl.cljc", :line 444, :type :var} {:name walk-select, :file "com/rpl/specter/impl.cljc", :line 598, :arglists ([pred continue-fn structure]), :type :var} {:name walk-until, :file "com/rpl/specter/impl.cljc", :line 612, :arglists ([pred on-match-fn structure]), :type :var})} {:name com.rpl.specter.macros, :publics ({:name defnav, :file "com/rpl/specter/macros.clj", :line 37, :arglists ([name params & impls]), :type :macro} {:name defrichnav, :file "com/rpl/specter/macros.clj", :line 48, :arglists ([name params & impls]), :type :macro} {:name nav, :file "com/rpl/specter/macros.clj", :line 23, :arglists ([params & impls]), :type :macro} {:name richnav, :file "com/rpl/specter/macros.clj", :line 14, :arglists ([params & impls]), :type :macro})} {:name com.rpl.specter.navs, :publics ({:name AddExtremes, :file "com/rpl/specter/navs.cljc", :line 420, :type :protocol, :members ({:name append-all, :arglists ([structure elements]), :type :var} {:name append-one, :arglists ([structure elem]), :type :var} {:name prepend-all, :arglists ([structure elements]), :type :var} {:name prepend-one, :arglists ([structure elem]), :type :var})} {:name all-select, :file "com/rpl/specter/navs.cljc", :line 25, :arglists ([structure next-fn]), :type :var} {:name AllTransformProtocol, :file "com/rpl/specter/navs.cljc", :line 39, :type :protocol, :members ({:name all-transform, :arglists ([structure next-fn]), :type :var})} {:name extract-basic-filter-fn, :file "com/rpl/specter/navs.cljc", :line 385, :arglists ([path]), :type :var} {:name FastEmpty, :file "com/rpl/specter/navs.cljc", :line 474, :type :protocol, :members ({:name fast-empty?, :arglists ([s]), :type :var})} {:name GetExtremes, :file "com/rpl/specter/navs.cljc", :line 470, :type :protocol, :members ({:name get-first, :arglists ([s]), :type :var} {:name get-last, :arglists ([s]), :type :var})} {:name if-select, :file "com/rpl/specter/navs.cljc", :line 401, :arglists ([vals structure next-fn then-tester then-nav else-nav]), :type :var} {:name if-transform, :file "com/rpl/specter/navs.cljc", :line 410, :arglists ([vals structure next-fn then-tester then-nav else-nav]), :type :var} {:name invoke-end-fn, :file "com/rpl/specter/navs.cljc", :line 689, :arglists ([end-fn structure start]), :type :var} {:name keypath*, :file "com/rpl/specter/navs.cljc", :line 637, :doc "Navigates to the specified key, navigating to nil if it does not exist.\nSetting the value to NONE will remove it from the collection.", :type :var} {:name map-keys-non-transient-transform, :file "com/rpl/specter/navs.cljc", :line 239, :arglists ([structure empty-map next-fn]), :type :var} {:name map-vals-non-transient-transform, :file "com/rpl/specter/navs.cljc", :line 229, :arglists ([structure empty-map next-fn]), :type :var} {:name MapTransformProtocol, :file "com/rpl/specter/navs.cljc", :line 222, :type :protocol, :members ({:name map-keys-transform, :arglists ([structure next-fn]), :type :var} {:name map-vals-transform, :arglists ([structure next-fn]), :type :var})} {:name must*, :file "com/rpl/specter/navs.cljc", :line 649, :doc "Navigates to the key only if it exists in the map. Setting the value to NONE\nwill remove it from the collection.", :type :var} {:name not-NONE?, :file "com/rpl/specter/navs.cljc", :line 56, :arglists ([v]), :type :var} {:name not-selected?*, :file "com/rpl/specter/navs.cljc", :line 14, :arglists ([compiled-path vals structure]), :type :var} {:name nthpath*, :file "com/rpl/specter/navs.cljc", :line 663, :type :var} {:name PosNavigator, :file "com/rpl/specter/navs.cljc", :line 477, :type :var} {:name queue?, :file "com/rpl/specter/navs.cljc", :line 31, :arglists ([coll]), :type :var} {:name selected?*, :file "com/rpl/specter/navs.cljc", :line 20, :arglists ([compiled-path vals structure]), :type :var} {:name srange-select, :file "com/rpl/specter/navs.cljc", :line 375, :arglists ([structure start end next-fn]), :type :var} {:name srange-transform, :file "com/rpl/specter/navs.cljc", :line 382, :type :var} {:name SrangeEndFunction, :file "com/rpl/specter/navs.cljc", :line 686, :type :var} {:name transient-vec-count, :file "com/rpl/specter/navs.cljc", :line 514, :arglists ([v]), :type :var} {:name UpdateExtremes, :file "com/rpl/specter/navs.cljc", :line 466, :type :protocol, :members ({:name update-first, :arglists ([s afn]), :type :var} {:name update-last, :arglists ([s afn]), :type :var})} {:name vec-count, :file "com/rpl/specter/navs.cljc", :line 504, :arglists ([v]), :type :var} {:name void-transformed-kv-pair?, :file "com/rpl/specter/navs.cljc", :line 42, :arglists ([newkv]), :type :var})} {:name com.rpl.specter.protocols, :publics ({:name Collector, :file "com/rpl/specter/protocols.cljc", :line 21, :doc "Do not use this protocol directly. All navigators must be created using\nmacros in com.rpl.specter namespace.", :type :protocol, :members ({:name collect-val, :arglists ([this structure]), :type :var})} {:name ImplicitNav, :file "com/rpl/specter/protocols.cljc", :line 26, :type :protocol, :members ({:name implicit-nav, :arglists ([obj]), :type :var})} {:name RichNavigator, :file "com/rpl/specter/protocols.cljc", :line 3, :doc "Do not use this protocol directly. All navigators must be created using macros\nin com.rpl.specter namespace.", :type :protocol, :members ({:name select*, :arglists ([this vals structure next-fn]), :doc "An implementation of `select*` must call `next-fn` on each\nsubvalue of `structure`. The result of `select*` is specified\nas follows:\n\n1. `NONE` if `next-fn` never called\n2. `NONE` if all calls to `next-fn` return `NONE`\n3. Otherwise, any non-`NONE` return value from calling `next-fn`\n", :type :var} {:name transform*, :arglists ([this vals structure next-fn]), :doc "An implementation of `transform*` must use `next-fn` to transform\nany subvalues of `structure` and then merge those transformed values\nback into `structure`. Everything else in `structure` must be unchanged.", :type :var})})} {:name com.rpl.specter.transients, :publics ({:name END!, :file "com/rpl/specter/transients.cljc", :line 24, :doc "Navigates to an empty (persistent) vector at the end of a transient vector.\n", :type :var} {:name FIRST!, :file "com/rpl/specter/transients.cljc", :line 52, :doc "Navigates to the first element of a transient vector.\n", :type :var} {:name keypath!, :file "com/rpl/specter/transients.cljc", :line 12, :doc "Navigates to the specified key of a transient collection,\nnavigating to nil if it doesn't exist.", :type :var} {:name LAST!, :file "com/rpl/specter/transients.cljc", :line 56, :doc "Navigates to the last element of a transient vector.\n", :type :var} {:name submap!, :file "com/rpl/specter/transients.cljc", :line 85, :doc "Navigates to the specified persistent submap of a transient map.\n", :type :var})} {:name com.rpl.specter.util-macros, :publics ({:name doseqres, :file "com/rpl/specter/util_macros.clj", :line 3, :arglists ([backup-res [n aseq] & body]), :type :macro} {:name late-fn-record-constructor-name, :file "com/rpl/specter/util_macros.clj", :line 38, :arglists ([i]), :type :var} {:name late-fn-record-name, :file "com/rpl/specter/util_macros.clj", :line 35, :arglists ([i]), :type :var} {:name mk-comp-navs, :file "com/rpl/specter/util_macros.clj", :line 17, :arglists ([]), :type :macro} {:name mk-late-fn, :file "com/rpl/specter/util_macros.clj", :line 56, :arglists ([]), :type :macro} {:name mk-late-fn-records, :file "com/rpl/specter/util_macros.clj", :line 52, :arglists ([]), :type :macro})} {:name com.rpl.specter.zipper, :publics ({:name DOWN, :file "com/rpl/specter/zipper.cljc", :line 58, :type :var} {:name find-first, :file "com/rpl/specter/zipper.cljc", :line 120, :doc "Navigate the zipper to the first element\nin the structure matching predfn. A linear scan\nis done using NEXT to find the element.", :type :var} {:name INNER-LEFT, :file "com/rpl/specter/zipper.cljc", :line 89, :doc "Navigate to the empty subsequence directly to the\nleft of this element.", :type :var} {:name INNER-RIGHT, :file "com/rpl/specter/zipper.cljc", :line 80, :doc "Navigate to the empty subsequence directly to the\nright of this element.", :type :var} {:name LEFT, :file "com/rpl/specter/zipper.cljc", :line 54, :doc "Navigate to the element to the left.\nIf no element there, works like STOP.", :type :var} {:name LEFTMOST, :file "com/rpl/specter/zipper.cljc", :line 66, :type :var} {:name NEXT, :file "com/rpl/specter/zipper.cljc", :line 24, :doc "Navigate to the next element in the structure.\nIf no next element, works like STOP.", :type :var} {:name NEXT-WALK, :file "com/rpl/specter/zipper.cljc", :line 131, :doc "Navigate to every element reachable using calls\nto NEXT", :type :var} {:name NODE, :file "com/rpl/specter/zipper.cljc", :line 98, :type :var} {:name NODE-SEQ, :file "com/rpl/specter/zipper.cljc", :line 106, :doc "Navigate to the subsequence containing only\nthe node currently pointed to. This works just\nlike srange and can be used to remove elements\nfrom the structure", :type :var} {:name PREV, :file "com/rpl/specter/zipper.cljc", :line 61, :doc "Navigate to the previous element.\nIf this is the first element, works like STOP.", :type :var} {:name RIGHT, :file "com/rpl/specter/zipper.cljc", :line 50, :doc "Navigate to the element to the right.\nIf no element there, works like STOP.", :type :var} {:name RIGHTMOST, :file "com/rpl/specter/zipper.cljc", :line 65, :type :var} {:name SEQ-ZIP, :file "com/rpl/specter/zipper.cljc", :line 20, :type :var} {:name UP, :file "com/rpl/specter/zipper.cljc", :line 59, :type :var} {:name VECTOR-ZIP, :file "com/rpl/specter/zipper.cljc", :line 19, :type :var} {:name XML-ZIP, :file "com/rpl/specter/zipper.cljc", :line 21, :type :var} {:name zipper, :file "com/rpl/specter/zipper.cljc", :line 12, :type :var})}), "cljs" ({:name com.rpl.specter, :publics ({:name AFTER-ELEM, :file "com/rpl/specter.cljc", :line 834, :doc "Navigate to 'void' element after the sequence.\nFor transformations – if result is not `NONE`,\nthen append that value.", :type :var} {:name ALL, :file "com/rpl/specter.cljc", :line 679, :doc "Navigate to every element of the collection. For maps navigates to\na vector of `[key value]`.", :type :var} {:name ALL-WITH-META, :file "com/rpl/specter.cljc", :line 689, :doc "Same as ALL, except maintains metadata on the structure.\n", :type :var} {:name ATOM, :file "com/rpl/specter.cljc", :line 1085, :doc "Navigates to atom value.\n", :type :var} {:name BEFORE-ELEM, :file "com/rpl/specter.cljc", :line 819, :doc "Navigate to 'void' element before the sequence.\nFor transformations – if result is not `NONE`,\nthen prepend that value.", :type :var} {:name before-index, :file "com/rpl/specter.cljc", :line 968, :doc "Navigates to the empty space between the index and the prior index. For select\nnavigates to NONE, and transforms to non-NONE insert at that position.", :type :var} {:name BEGINNING, :file "com/rpl/specter.cljc", :line 777, :doc "Navigate to the empty subsequence before the first element of the collection.\n", :type :var} {:name codewalker, :file "com/rpl/specter.cljc", :line 1455, :doc "Like `walker` but maintains metadata of any forms traversed.\n", :type :var} {:name collect, :file "com/rpl/specter.cljc", :line 1292, :doc "Adds the result of running select with the given path on the\ncurrent value to the collected vals.", :type :var} {:name collect-one, :file "com/rpl/specter.cljc", :line 1302, :doc "Adds the result of running select-one with the given path on the\ncurrent value to the collected vals.", :type :var} {:name collected?, :file "com/rpl/specter.cljc", :line 399, :arglists ([params & body]), :doc "Creates a filter function navigator that takes in all the collected values\nas input. For arguments, can use `(collected? [a b] ...)` syntax to look\nat each collected value as individual arguments, or `(collected? v ...)` syntax\nto capture all the collected values as a single vector.", :type :macro} {:name collector, :file "com/rpl/specter.cljc", :line 67, :arglists ([params [_ [_ structure-sym] & body]]), :type :macro} {:name comp-paths, :file "com/rpl/specter.cljc", :line 478, :arglists ([& apath]), :doc "Returns a compiled version of the given path for use with\ncompiled-{select/transform/setval/etc.} functions.", :type :var} {:name compact, :file "com/rpl/specter.cljc", :line 1465, :doc "During transforms, after each step of navigation in subpath check if the\nvalue is empty. If so, remove that value by setting it to NONE.", :type :var} {:name compiled-multi-transform, :file "com/rpl/specter.cljc", :line 575, :doc "Version of `multi-transform` that takes in a path precompiled with `comp-paths`\n", :type :var} {:name compiled-replace-in, :file "com/rpl/specter.cljc", :line 596, :doc "Version of replace-in that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-select, :file "com/rpl/specter.cljc", :line 486, :doc "Version of select that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-select-any, :file "com/rpl/specter.cljc", :line 520, :doc "Version of select-any that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-select-first, :file "com/rpl/specter.cljc", :line 511, :doc "Version of select-first that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-select-one, :file "com/rpl/specter.cljc", :line 495, :doc "Version of select-one that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-select-one!, :file "com/rpl/specter.cljc", :line 503, :doc "Version of select-one! that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-selected-any?, :file "com/rpl/specter.cljc", :line 533, :doc "Version of selected-any? that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-setval, :file "com/rpl/specter.cljc", :line 588, :doc "Version of setval that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-transform, :file "com/rpl/specter.cljc", :line 562, :doc "Version of transform that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-traverse, :file "com/rpl/specter.cljc", :line 543, :doc "Version of traverse that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-traverse-all, :file "com/rpl/specter.cljc", :line 552, :doc "Version of traverse-all that takes in a path precompiled with comp-paths\n", :type :var} {:name compiled-vtransform, :file "com/rpl/specter.cljc", :line 565, :doc "Version of vtransform that takes in a path precompiled with comp-paths\n", :type :var} {:name cond-path, :file "com/rpl/specter.cljc", :line 1394, :doc "Takes in alternating cond-path path cond-path path...\nTests the structure if selecting with cond-path returns anything.\nIf so, it uses the following path for this portion of the navigation.\nOtherwise, it tries the next cond-path. If nothing matches, then the structure\nis not selected.", :type :var} {:name continue-then-stay, :file "com/rpl/specter.cljc", :line 1439, :doc "Navigates to the provided path and then to the current element. This can be used\nto implement post-order traversal.", :type :var} {:name continuous-subseqs, :file "com/rpl/specter.cljc", :line 766, :doc "Navigates to every continuous subsequence of elements matching `pred`\n", :type :var} {:name declarepath, :file "com/rpl/specter.cljc", :line 101, :arglists ([name]), :type :macro} {:name defcollector, :file "com/rpl/specter.cljc", :line 74, :arglists ([name & body]), :type :macro} {:name defdynamicnav, :file "com/rpl/specter.cljc", :line 147, :arglists ([name & args]), :doc "Defines a function that can choose what navigator to use at runtime based on\nthe dynamic context. The arguments will either be static values or\nobjects satisfying `dynamic-param?`. Use `late-bound-nav` to produce a runtime\nnavigator that uses the values of the dynamic params. See `selected?` for\nan illustrative example of dynamic navs.", :type :macro} {:name defmacroalias, :file "com/rpl/specter.cljc", :line 57, :arglists ([name target]), :type :macro} {:name defnav, :file "com/rpl/specter.cljc", :line 64, :type :macro} {:name defprotocolpath, :file "com/rpl/specter.cljc", :line 415, :arglists ([name] [name params]), :doc "Defines a navigator that chooses the path to take based on the type\nof the value at the current point. May be specified with parameters to\nspecify that all extensions must require that number of parameters.\n\nCurrently not available for ClojureScript.\n\nExample of usage:\n(defrecord SingleAccount [funds])\n(defrecord FamilyAccount [single-accounts])\n\n(defprotocolpath FundsPath)\n(extend-protocolpath FundsPath\n  SingleAccount :funds\n  FamilyAccount [ALL FundsPath]\n  )\n", :type :macro} {:name defrichnav, :file "com/rpl/specter.cljc", :line 65, :type :macro} {:name DISPENSE, :file "com/rpl/specter.cljc", :line 1340, :doc "Drops all collected values for subsequent navigation.\n", :type :var} {:name dynamic-param?, :file "com/rpl/specter.cljc", :line 611, :type :var} {:name dynamicnav, :file "com/rpl/specter.cljc", :line 144, :arglists ([& args]), :type :macro} {:name eachnav, :file "com/rpl/specter.cljc", :line 615, :doc "Turns a navigator that takes one argument into a navigator that takes\nmany arguments and uses the same navigator with each argument. There\nis no performance cost to using this. See implementation of `keypath`", :type :var} {:name END, :file "com/rpl/specter.cljc", :line 790, :doc "Navigate to the empty subsequence after the last element of the collection.\n", :type :var} {:name end-fn, :file "com/rpl/specter.cljc", :line 471, :arglists ([& args]), :type :macro} {:name extend-protocolpath, :file "com/rpl/specter.cljc", :line 462, :arglists ([protpath & extensions]), :doc "Used in conjunction with `defprotocolpath`. See [[defprotocolpath]].\n", :type :macro} {:name filterer, :file "com/rpl/specter.cljc", :line 1141, :doc "Navigates to a view of the current sequence that only contains elements that\nmatch the given path. An element matches the selector path if calling select\non that element with the path yields anything other than an empty sequence.\n\nFor transformation: `NONE` entries in the result sequence cause corresponding entries in\ninput to be removed. A result sequence smaller than the input sequence is equivalent to\npadding the result sequence with `NONE` at the end until the same size as the input.", :type :var} {:name FIRST, :file "com/rpl/specter.cljc", :line 735, :doc "Navigate to the first element of the collection. If the collection is\nempty navigation is stopped at this point.", :type :var} {:name if-path, :file "com/rpl/specter.cljc", :line 1349, :doc "Like cond-path, but with if semantics.\n", :type :var} {:name index-nav, :file "com/rpl/specter.cljc", :line 983, :doc "Navigates to the index of the sequence if within 0 and size. Transforms move element\nat that index to the new index, shifting other elements in the sequence.", :type :var} {:name INDEXED-VALS, :file "com/rpl/specter.cljc", :line 1058, :doc "`indexed-vals` with a starting index of 0.\n", :type :var} {:name indexed-vals, :file "com/rpl/specter.cljc", :line 1022, :doc "Navigate to [index elem] pairs for each element in a sequence. The sequence will be indexed\nstarting from `start`. Changing index in transform has same effect as `index-nav`. Indices seen\nduring transform take into account any shifting from prior sequence elements changing indices.", :type :var} {:name keypath, :file "com/rpl/specter.cljc", :line 952, :doc "Navigate to the specified keys one after another. If navigate to NONE,\nthat element is removed from the map or vector.", :type :var} {:name LAST, :file "com/rpl/specter.cljc", :line 729, :doc "Navigate to the last element of the collection. If the collection is\nempty navigation is stopped at this point.", :type :var} {:name late-bound-collector, :file "com/rpl/specter.cljc", :line 91, :arglists ([bindings impl]), :type :macro} {:name late-bound-nav, :file "com/rpl/specter.cljc", :line 88, :arglists ([bindings & impls]), :type :macro} {:name late-bound-richnav, :file "com/rpl/specter.cljc", :line 94, :arglists ([bindings & impls]), :type :macro} {:name late-path, :file "com/rpl/specter.cljc", :line 610, :type :var} {:name late-resolved-fn, :file "com/rpl/specter.cljc", :line 612, :type :var} {:name local-declarepath, :file "com/rpl/specter.cljc", :line 628, :type :var} {:name map-key, :file "com/rpl/specter.cljc", :line 909, :doc "Navigates to the given key in the map (not to the value). Navigates only if the\nkey currently exists in the map. Can transform to NONE to remove the key/value\npair from the map.", :type :var} {:name MAP-KEYS, :file "com/rpl/specter.cljc", :line 713, :doc "Navigate to each key of the map. This is more efficient than\nnavigating via [ALL FIRST]", :type :var} {:name MAP-VALS, :file "com/rpl/specter.cljc", :line 702, :doc "Navigate to each value of the map. This is more efficient than\nnavigating via [ALL LAST]", :type :var} {:name META, :file "com/rpl/specter.cljc", :line 1257, :doc "Navigates to the metadata of the structure, or nil if\nthe structure has no metadata or may not contain metadata.", :type :var} {:name multi-path, :file "com/rpl/specter.cljc", :line 1409, :doc "A path that branches on multiple paths. For updates,\napplies updates to the paths in order.", :type :var} {:name multi-transform, :file "com/rpl/specter.cljc", :line 361, :arglists ([apath structure]), :doc "Just like `transform` but expects transform functions to be specified\ninline in the path using `terminal` or `vterminal`. Error is thrown if navigation finishes\nat a non-terminal navigator. `terminal-val` is a wrapper around `terminal` and is\nthe `multi-transform` equivalent of `setval`.\nThis macro will do inline caching of the path.", :type :macro} {:name multi-transform*, :file "com/rpl/specter.cljc", :line 579, :arglists ([path structure]), :doc "Just like `transform` but expects transform functions to be specified\ninline in the path using `terminal` or `vterminal`. Error is thrown if navigation finishes\nat a non-terminal navigator. `terminal-val` is a wrapper around `terminal` and is\nthe `multi-transform` equivalent of `setval`.", :type :var} {:name must, :file "com/rpl/specter.cljc", :line 957, :doc "Navigate to the specified keys one after another, only if they exist\nin the data structure. If navigate to NONE, that element is removed\nfrom the map or vector.", :type :var} {:name NAME, :file "com/rpl/specter.cljc", :line 1266, :doc "Navigates to the name portion of the keyword or symbol\n", :type :var} {:name NAMESPACE, :file "com/rpl/specter.cljc", :line 1279, :doc "Navigates to the namespace portion of the keyword or symbol\n", :type :var} {:name nav, :file "com/rpl/specter.cljc", :line 63, :type :macro} {:name NIL->LIST, :file "com/rpl/specter.cljc", :line 1245, :doc "Navigates to '() if the value is nil. Otherwise it stays\nnavigated at the current value.", :type :var} {:name NIL->SET, :file "com/rpl/specter.cljc", :line 1239, :doc "Navigates to #{} if the value is nil. Otherwise it stays\nnavigated at the current value.", :type :var} {:name nil->val, :file "com/rpl/specter.cljc", :line 1229, :doc "Navigates to the provided val if the structure is nil. Otherwise it stays\nnavigated at the structure.", :type :var} {:name NIL->VECTOR, :file "com/rpl/specter.cljc", :line 1251, :doc "Navigates to [] if the value is nil. Otherwise it stays\nnavigated at the current value.", :type :var} {:name NONE, :file "com/rpl/specter.cljc", :line 523, :doc "Global value used to indicate no elements selected during\n[[select-any]].", :type :var} {:name NONE-ELEM, :file "com/rpl/specter.cljc", :line 802, :doc "Navigate to 'void' elem in the set.\nFor transformations - if result is not `NONE`,\nthen add that value to the set.", :type :var} {:name not-selected?, :file "com/rpl/specter.cljc", :line 1124, :type :var} {:name nthpath, :file "com/rpl/specter.cljc", :line 963, :doc "Navigate to the specified indices one after another. If navigate to\nNONE, that element is removed from the sequence.", :type :var} {:name parser, :file "com/rpl/specter.cljc", :line 1073, :doc "Navigate to the result of running `parse-fn` on the value. For\ntransforms, the transformed value then has `unparse-fn` run on\nit to get the final value at this point.", :type :var} {:name path, :file "com/rpl/specter.cljc", :line 232, :arglists ([& path]), :doc "Same as calling comp-paths, except it caches the composition of the static parts\nof the path for later re-use (when possible). For almost all idiomatic uses\nof Specter provides huge speedup. This macro is automatically used by the\nselect/transform/setval/replace-in/etc. macros.", :type :macro} {:name pred, :file "com/rpl/specter.cljc", :line 1175, :doc "Keeps the element only if it matches the supplied predicate. Functions in paths\nimplicitly convert to this navigator.", :type :var} {:name pred<, :file "com/rpl/specter.cljc", :line 1184, :arglists ([v]), :type :var} {:name pred<=, :file "com/rpl/specter.cljc", :line 1186, :arglists ([v]), :type :var} {:name pred=, :file "com/rpl/specter.cljc", :line 1183, :arglists ([v]), :type :var} {:name pred>, :file "com/rpl/specter.cljc", :line 1185, :arglists ([v]), :type :var} {:name pred>=, :file "com/rpl/specter.cljc", :line 1187, :arglists ([v]), :type :var} {:name providepath, :file "com/rpl/specter.cljc", :line 104, :arglists ([name apath]), :type :macro} {:name putval, :file "com/rpl/specter.cljc", :line 1312, :doc "Adds an external value to the collected vals. Useful when additional arguments\nare required to the transform function that would otherwise require partial\napplication or a wrapper function.\n\ne.g., incrementing val at path [:a :b] by 3:\n(transform [:a :b (putval 3)] + some-map)", :type :var} {:name recursive-path, :file "com/rpl/specter.cljc", :line 107, :arglists ([params self-sym path]), :type :macro} {:name regex-nav, :file "com/rpl/specter.cljc", :line 1096, :type :var} {:name replace-in, :file "com/rpl/specter.cljc", :line 389, :arglists ([apath transform-fn structure & args]), :doc "Similar to transform, except returns a pair of [transformed-structure sequence-of-user-ret].\nThe transform-fn in this case is expected to return [ret user-ret]. ret is\nwhat's used to transform the data structure, while user-ret will be added to the user-ret sequence\nin the final return. replace-in is useful for situations where you need to know the specific values\nof what was transformed in the data structure.\nThis macro will do inline caching of the path.", :type :macro} {:name replace-in*, :file "com/rpl/specter.cljc", :line 599, :arglists ([path transform-fn structure & {:keys [merge-fn], :or {merge-fn concat}}]), :doc "Similar to transform, except returns a pair of [transformed-structure sequence-of-user-ret].\nThe transform-fn in this case is expected to return [ret user-ret]. ret is\nwhat's used to transform the data structure, while user-ret will be added to the user-ret sequence\nin the final return. replace-in is useful for situations where you need to know the specific values\nof what was transformed in the data structure.", :type :var} {:name richnav, :file "com/rpl/specter.cljc", :line 62, :type :macro} {:name satisfies-protpath?, :file "com/rpl/specter.cljc", :line 451, :arglists ([protpath o]), :type :macro} {:name select, :file "com/rpl/specter.cljc", :line 311, :arglists ([apath structure]), :doc "Navigates to and returns a sequence of all the elements specified by the path.\nThis macro will do inline caching of the path.", :type :macro} {:name select*, :file "com/rpl/specter.cljc", :line 489, :arglists ([path structure]), :doc "Navigates to and returns a sequence of all the elements specified by the path.\n", :type :var} {:name select-any, :file "com/rpl/specter.cljc", :line 335, :arglists ([apath structure]), :doc "Returns any element found or [[NONE]] if nothing selected. This is the most\nefficient of the various selection operations.\nThis macro will do inline caching of the path.", :type :macro} {:name select-any*, :file "com/rpl/specter.cljc", :line 527, :arglists ([path structure]), :doc "Returns any element found or [[NONE]] if nothing selected. This is the most\nefficient of the various selection operations.", :type :var} {:name select-first, :file "com/rpl/specter.cljc", :line 329, :arglists ([apath structure]), :doc "Returns first element found.\nThis macro will do inline caching of the path.", :type :macro} {:name select-first*, :file "com/rpl/specter.cljc", :line 515, :arglists ([path structure]), :doc "Returns first element found.\n", :type :var} {:name select-one, :file "com/rpl/specter.cljc", :line 323, :arglists ([apath structure]), :doc "Like select, but returns either one element or nil. Throws exception if multiple elements found.\nThis macro will do inline caching of the path.", :type :macro} {:name select-one!, :file "com/rpl/specter.cljc", :line 317, :arglists ([apath structure]), :doc "Returns exactly one element, throws exception if zero or multiple elements found.\nThis macro will do inline caching of the path.", :type :macro} {:name select-one!*, :file "com/rpl/specter.cljc", :line 506, :arglists ([path structure]), :doc "Returns exactly one element, throws exception if zero or multiple elements found\n", :type :var} {:name select-one*, :file "com/rpl/specter.cljc", :line 498, :arglists ([path structure]), :doc "Like select, but returns either one element or nil. Throws exception if multiple elements found\n", :type :var} {:name selected-any?, :file "com/rpl/specter.cljc", :line 342, :arglists ([apath structure]), :doc "Returns true if any element was selected, false otherwise.\nThis macro will do inline caching of the path.", :type :macro} {:name selected-any?*, :file "com/rpl/specter.cljc", :line 536, :arglists ([path structure]), :doc "Returns true if any element was selected, false otherwise.\n", :type :var} {:name selected?, :file "com/rpl/specter.cljc", :line 1103, :doc "Filters the current value based on whether a path finds anything.\ne.g. (selected? :vals ALL even?) keeps the current element only if an\neven number exists for the :vals key.", :type :var} {:name set-elem, :file "com/rpl/specter.cljc", :line 931, :doc "Navigates to the given element in the set only if it exists in the set.\nCan transform to NONE to remove the element from the set.", :type :var} {:name setval, :file "com/rpl/specter.cljc", :line 371, :arglists ([apath aval structure]), :doc "Navigates to each value specified by the path and replaces it by `aval`.\nThis macro will do inline caching of the path.", :type :macro} {:name setval*, :file "com/rpl/specter.cljc", :line 591, :arglists ([path val structure]), :doc "Navigates to each value specified by the path and replaces it by val\n", :type :var} {:name srange, :file "com/rpl/specter.cljc", :line 755, :doc "Navigates to the subsequence bound by the indexes start (inclusive)\nand end (exclusive)", :type :var} {:name srange-dynamic, :file "com/rpl/specter.cljc", :line 741, :doc "Uses start-index-fn and end-index-fn to determine the bounds of the subsequence\nto select when navigating. `start-index-fn` takes in the structure as input. `end-index-fn`\ncan be one of two forms. If a regular function (e.g. defined with `fn`), it takes in only the structure as input. If a function defined using special `end-fn` macro, it takes in the structure and the result of `start-index-fn`.", :type :var} {:name STAY, :file "com/rpl/specter.cljc", :line 644, :doc "Stays navigated at the current point. Essentially a no-op navigator.\n", :type :var} {:name stay-then-continue, :file "com/rpl/specter.cljc", :line 1433, :doc "Navigates to the current element and then navigates via the provided path.\nThis can be used to implement pre-order traversal.", :type :var} {:name STOP, :file "com/rpl/specter.cljc", :line 632, :doc "Stops navigation at this point. For selection returns nothing and for\ntransformation returns the structure unchanged", :type :var} {:name submap, :file "com/rpl/specter.cljc", :line 865, :doc "Navigates to the specified submap (using select-keys).\nIn a transform, that submap in the original map is changed to the new\nvalue of the submap.", :type :var} {:name subselect, :file "com/rpl/specter.cljc", :line 880, :doc "Navigates to a sequence that contains the results of (select ...),\nbut is a view to the original structure that can be transformed.\n\nRequires that the input navigators will walk the structure's\nchildren in the same order when executed on \"select\" and then\n\"transform\".\n\nIf transformed sequence is smaller than input sequence, missing entries\nwill be filled in with NONE, triggering removal if supported by that navigator.\n\nValue collection (e.g. collect, collect-one) may not be used in the subpath.", :type :var} {:name subset, :file "com/rpl/specter.cljc", :line 849, :doc "Navigates to the specified subset (by taking an intersection).\nIn a transform, that subset in the original set is changed to the\nnew value of the subset.", :type :var} {:name terminal, :file "com/rpl/specter.cljc", :line 649, :doc "Defines an endpoint in the navigation the transform function run. The transform\nfunction works just like it does in `transform`, with collected values\ngiven as the first arguments", :type :var} {:name terminal-val, :file "com/rpl/specter.cljc", :line 673, :arglists ([v]), :doc "Like `terminal` but specifies a val to set at the location regardless of\nthe collected values or the value at the location.", :type :var} {:name transform, :file "com/rpl/specter.cljc", :line 348, :arglists ([apath transform-fn structure]), :doc "Navigates to each value specified by the path and replaces it by the result of running\nthe transform-fn on it.\nThis macro will do inline caching of the path.", :type :macro} {:name transform*, :file "com/rpl/specter.cljc", :line 569, :arglists ([path transform-fn structure]), :doc "Navigates to each value specified by the path and replaces it by the result of running\nthe transform-fn on it", :type :var} {:name transformed, :file "com/rpl/specter.cljc", :line 1152, :doc "Navigates to a view of the current value by transforming it with the\nspecified path and update-fn.", :type :var} {:name traverse, :file "com/rpl/specter.cljc", :line 377, :arglists ([apath structure]), :doc "Return a reducible object that traverses over `structure` to every element\nspecified by the path.\nThis macro will do inline caching of the path.", :type :macro} {:name traverse*, :file "com/rpl/specter.cljc", :line 546, :arglists ([apath structure]), :doc "Return a reducible object that traverses over `structure` to every element\nspecified by the path", :type :var} {:name traverse-all, :file "com/rpl/specter.cljc", :line 384, :arglists ([apath]), :doc "Returns a transducer that traverses over each element with the given path.\n", :type :macro} {:name traverse-all*, :file "com/rpl/specter.cljc", :line 555, :arglists ([apath]), :doc "Returns a transducer that traverses over each element with the given path.\n", :type :var} {:name traversed, :file "com/rpl/specter.cljc", :line 1163, :doc "Navigates to a view of the current value by transforming with a reduction over\nthe specified traversal.", :type :var} {:name VAL, :file "com/rpl/specter.cljc", :line 725, :type :var} {:name view, :file "com/rpl/specter.cljc", :line 1063, :doc "Navigates to result of running `afn` on the currently navigated value.\n", :type :var} {:name vterminal, :file "com/rpl/specter.cljc", :line 660, :doc "Defines an endpoint in the navigation the transform function run.The transform\nfunction works differently than it does in `transform`. Rather than receive\ncollected vals spliced in as the first arguments to the function, this function\nalways takes two arguemnts. The first is all collected vals in a vector, and\nthe second is the navigated value.", :type :var} {:name vtransform, :file "com/rpl/specter.cljc", :line 355, :arglists ([apath transform-fn structure]), :doc "Navigates to each value specified by the path and replaces it by the result of running\nthe transform-fn on two arguments: the collected values as a vector, and the navigated value.", :type :macro} {:name walker, :file "com/rpl/specter.cljc", :line 1445, :doc "Navigate the data structure until reaching\na value for which `afn` returns truthy. Has\nsame semantics as clojure.walk.", :type :var} {:name with-fresh-collected, :file "com/rpl/specter.cljc", :line 1325, :doc "Continues navigating on the given path with the collected vals reset to []. Once\nnavigation leaves the scope of with-fresh-collected, the collected vals revert\nto what they were before.", :type :var} {:name with-inline-debug, :file "com/rpl/specter.cljc", :line 97, :arglists ([& body]), :type :macro} {:name wrap-dynamic-nav, :file "com/rpl/specter.cljc", :line 41, :arglists ([f]), :type :var})} {:name com.rpl.specter.impl, :publics ({:name *DEBUG-INLINE-CACHING*, :file "com/rpl/specter/impl.cljc", :line 902, :dynamic true, :type :var} {:name *path-compile-files*, :file "com/rpl/specter/impl.cljc", :line 911, :dynamic true, :type :var} {:name all-static?, :file "com/rpl/specter/impl.cljc", :line 689, :arglists ([params]), :type :var} {:name benchmark, :file "com/rpl/specter/impl.cljc", :line 109, :arglists ([iters afn]), :type :var} {:name cached-path-info-dynamic?, :file "com/rpl/specter/impl.cljc", :line 488, :arglists ([c]), :type :var} {:name cached-path-info-precompiled, :file "com/rpl/specter/impl.cljc", :line 485, :arglists ([c]), :type :var} {:name CachedPathInfo, :file "com/rpl/specter/impl.cljc", :line 478, :type :var} {:name cell-nav, :file "com/rpl/specter/impl.cljc", :line 524, :arglists ([cell]), :type :var} {:name clj-macroexpand-all, :file "com/rpl/specter/impl.cljc", :line 91, :arglists ([form]), :type :var} {:name cljs-analyzer-macroexpand-1, :file "com/rpl/specter/impl.cljc", :line 81, :arglists ([]), :type :var} {:name codewalk-until, :file "com/rpl/specter/impl.cljc", :line 590, :arglists ([pred on-match-fn structure]), :type :var} {:name coerce-nav, :file "com/rpl/specter/impl.cljc", :line 654, :arglists ([o]), :type :var} {:name CoercePath, :file "com/rpl/specter/impl.cljc", :line 158, :type :protocol, :members ({:name coerce-path, :arglists ([this]), :type :var})} {:name collected?*, :file "com/rpl/specter/impl.cljc", :line 513, :arglists ([afn]), :type :var} {:name combine-two-navs, :file "com/rpl/specter/impl.cljc", :line 197, :arglists ([nav1 nav2]), :type :var} {:name comp-navs, :file "com/rpl/specter/impl.cljc", :line 544, :arglists ([] [nav1__1045__auto__] [nav1__1045__auto__ nav2__1046__auto__] [G__5523 G__5524 G__5525] [G__5526 G__5527 G__5528 G__5529] [G__5530 G__5531 G__5532 G__5533 G__5534] [G__5535 G__5536 G__5537 G__5538 G__5539 G__5540] [G__5541 G__5542 G__5543 G__5544 G__5545 G__5546 G__5547] [G__5548 G__5549 G__5550 G__5551 G__5552 G__5553 G__5554 G__5555] [G__5556 G__5557 G__5558 G__5559 G__5560 G__5561 G__5562 G__5563 G__5564] [G__5565 G__5566 G__5567 G__5568 G__5569 G__5570 G__5571 G__5572 G__5573 G__5574] [G__5575 G__5576 G__5577 G__5578 G__5579 G__5580 G__5581 G__5582 G__5583 G__5584 G__5585] [G__5586 G__5587 G__5588 G__5589 G__5590 G__5591 G__5592 G__5593 G__5594 G__5595 G__5596 G__5597] [G__5598 G__5599 G__5600 G__5601 G__5602 G__5603 G__5604 G__5605 G__5606 G__5607 G__5608 G__5609 G__5610] [G__5611 G__5612 G__5613 G__5614 G__5615 G__5616 G__5617 G__5618 G__5619 G__5620 G__5621 G__5622 G__5623 G__5624] [G__5625 G__5626 G__5627 G__5628 G__5629 G__5630 G__5631 G__5632 G__5633 G__5634 G__5635 G__5636 G__5637 G__5638 G__5639] [G__5640 G__5641 G__5642 G__5643 G__5644 G__5645 G__5646 G__5647 G__5648 G__5649 G__5650 G__5651 G__5652 G__5653 G__5654 G__5655] [G__5656 G__5657 G__5658 G__5659 G__5660 G__5661 G__5662 G__5663 G__5664 G__5665 G__5666 G__5667 G__5668 G__5669 G__5670 G__5671 G__5672] [G__5673 G__5674 G__5675 G__5676 G__5677 G__5678 G__5679 G__5680 G__5681 G__5682 G__5683 G__5684 G__5685 G__5686 G__5687 G__5688 G__5689 G__5690] [G__5691 G__5692 G__5693 G__5694 G__5695 G__5696 G__5697 G__5698 G__5699 G__5700 G__5701 G__5702 G__5703 G__5704 G__5705 G__5706 G__5707 G__5708 G__5709] [G__5504 G__5505 G__5506 G__5507 G__5508 G__5509 G__5510 G__5511 G__5512 G__5513 G__5514 G__5515 G__5516 G__5517 G__5518 G__5519 G__5520 G__5521 G__5522 & rest__1047__auto__]), :type :var} {:name comp-paths*, :file "com/rpl/specter/impl.cljc", :line 149, :arglists ([p]), :type :var} {:name compiled-multi-transform*, :file "com/rpl/specter/impl.cljc", :line 992, :arglists ([path structure]), :type :var} {:name compiled-replace-in*, :file "com/rpl/specter/impl.cljc", :line 970, :arglists ([path transform-fn structure & {:keys [merge-fn], :or {merge-fn concat}}]), :type :var} {:name compiled-select*, :file "com/rpl/specter/impl.cljc", :line 364, :arglists ([path structure]), :type :var} {:name compiled-select-any*, :file "com/rpl/specter/impl.cljc", :line 403, :arglists ([path structure] [path vals structure]), :type :var} {:name compiled-select-first*, :file "com/rpl/specter/impl.cljc", :line 408, :arglists ([path structure]), :type :var} {:name compiled-select-one!*, :file "com/rpl/specter/impl.cljc", :line 388, :arglists ([path structure]), :type :var} {:name compiled-select-one*, :file "com/rpl/specter/impl.cljc", :line 373, :arglists ([path structure]), :type :var} {:name compiled-selected-any?*, :file "com/rpl/specter/impl.cljc", :line 415, :arglists ([path structure]), :type :var} {:name compiled-setval*, :file "com/rpl/specter/impl.cljc", :line 967, :arglists ([path val structure]), :type :var} {:name compiled-transform*, :file "com/rpl/specter/impl.cljc", :line 425, :arglists ([nav transform-fn structure]), :type :var} {:name compiled-traverse*, :file "com/rpl/specter/impl.cljc", :line 303, :arglists ([path result-fn structure]), :type :var} {:name compiled-traverse-all*, :file "com/rpl/specter/impl.cljc", :line 349, :arglists ([path]), :type :var} {:name compiled-traverse-with-vals*, :file "com/rpl/specter/impl.cljc", :line 292, :arglists ([path result-fn vals structure]), :type :var} {:name compiled-vtransform*, :file "com/rpl/specter/impl.cljc", :line 430, :arglists ([nav transform-fn structure]), :type :var} {:name continuous-subseqs-transform*, :file "com/rpl/specter/impl.cljc", :line 583, :arglists ([pred structure next-fn]), :type :var} {:name direct-nav-obj, :file "com/rpl/specter/impl.cljc", :line 672, :arglists ([o]), :type :var} {:name direct-nav?, :file "com/rpl/specter/impl.cljc", :line 686, :arglists ([o]), :type :var} {:name do-compiled-traverse, :file "com/rpl/specter/impl.cljc", :line 337, :arglists ([apath structure]), :type :var} {:name do-compiled-traverse*, :file "com/rpl/specter/impl.cljc", :line 306, :arglists ([apath structure]), :type :var} {:name dynamic->code, :file "com/rpl/specter/impl.cljc", :line 834, :arglists ([o]), :type :var} {:name dynamic-fn-code, :file "com/rpl/specter/impl.cljc", :line 805, :arglists ([afn args]), :type :var} {:name dynamic-param?, :file "com/rpl/specter/impl.cljc", :line 463, :arglists ([o]), :type :var} {:name dynamic-val-code, :file "com/rpl/specter/impl.cljc", :line 813, :arglists ([code possible-params]), :type :var} {:name dynamic-var?, :file "com/rpl/specter/impl.cljc", :line 666, :arglists ([v]), :type :var} {:name DynamicFunction, :file "com/rpl/specter/impl.cljc", :line 460, :type :var} {:name DynamicPath, :file "com/rpl/specter/impl.cljc", :line 457, :type :var} {:name DynamicVal, :file "com/rpl/specter/impl.cljc", :line 454, :type :var} {:name exec-select*, :file "com/rpl/specter/impl.cljc", :line 124, :arglists ([this vals structure next-fn]), :type :var} {:name exec-transform*, :file "com/rpl/specter/impl.cljc", :line 139, :arglists ([this vals structure next-fn]), :type :var} {:name fast-constantly, :file "com/rpl/specter/impl.cljc", :line 38, :arglists ([v]), :type :var} {:name fast-object-array, :file "com/rpl/specter/impl.cljc", :line 105, :arglists ([i]), :type :macro} {:name filter-select, :file "com/rpl/specter/impl.cljc", :line 492, :arglists ([afn vals structure next-fn]), :type :var} {:name filter-transform, :file "com/rpl/specter/impl.cljc", :line 497, :arglists ([afn vals structure next-fn]), :type :var} {:name fn-invocation?, :file "com/rpl/specter/impl.cljc", :line 433, :arglists ([f]), :type :var} {:name FnInvocation, :file "com/rpl/specter/impl.cljc", :line 450, :type :var} {:name get-cell, :file "com/rpl/specter/impl.cljc", :line 268, :arglists ([cell]), :type :var} {:name intern*, :file "com/rpl/specter/impl.cljc", :line 100, :arglists ([ns name val]), :type :var} {:name late-fn, :file "com/rpl/specter/impl.cljc", :line 790, :arglists ([afn6079 args6080]), :type :var} {:name late-path, :file "com/rpl/specter/impl.cljc", :line 471, :arglists ([path]), :type :var} {:name late-resolved-fn, :file "com/rpl/specter/impl.cljc", :line 692, :arglists ([afn]), :type :var} {:name LateFn0, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn1, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn10, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn11, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn12, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn13, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn14, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn15, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn16, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn17, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn18, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn19, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn2, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn3, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn4, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn5, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn6, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn7, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn8, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateFn9, :file "com/rpl/specter/impl.cljc", :line 789, :type :var} {:name LateResolve, :file "com/rpl/specter/impl.cljc", :line 774, :type :protocol, :members ({:name late-resolve, :arglists ([this dynamic-params]), :type :var})} {:name local-declarepath, :file "com/rpl/specter/impl.cljc", :line 531, :arglists ([]), :type :var} {:name LocalParam, :file "com/rpl/specter/impl.cljc", :line 778, :type :var} {:name LocalSym, :file "com/rpl/specter/impl.cljc", :line 439, :type :var} {:name magic-precompilation, :file "com/rpl/specter/impl.cljc", :line 946, :arglists ([path ns-str used-locals-list possible-params]), :type :var} {:name matching-ranges, :file "com/rpl/specter/impl.cljc", :line 566, :arglists ([aseq p]), :type :var} {:name maybe-direct-nav, :file "com/rpl/specter/impl.cljc", :line 675, :arglists ([obj direct-nav?]), :type :var} {:name mk-dynamic-path-maker, :file "com/rpl/specter/impl.cljc", :line 928, :arglists ([resolved-code ns-str used-locals-list possible-params]), :type :var} {:name mk-fn-name-strs, :file "com/rpl/specter/impl.cljc", :line 905, :arglists ([o]), :type :var} {:name mutable-cell, :file "com/rpl/specter/impl.cljc", :line 246, :arglists ([] [init]), :type :var} {:name MutableCell, :file "com/rpl/specter/impl.cljc", :line 234, :type :var} {:name NONE, :file "com/rpl/specter/impl.cljc", :line 23, :type :var} {:name original-obj, :file "com/rpl/specter/impl.cljc", :line 680, :arglists ([o]), :type :var} {:name PathComposer, :file "com/rpl/specter/impl.cljc", :line 142, :type :protocol, :members ({:name do-comp-paths, :arglists ([paths]), :type :var})} {:name PMutableCell, :file "com/rpl/specter/impl.cljc", :line 229, :type :protocol, :members ({:name set_cell, :arglists ([cell x]), :type :var})} {:name pred*, :file "com/rpl/specter/impl.cljc", :line 502, :arglists ([afn]), :type :var} {:name preserve-map, :file "com/rpl/specter/impl.cljc", :line 699, :arglists ([afn o]), :type :var} {:name providepath*, :file "com/rpl/specter/impl.cljc", :line 535, :arglists ([declared compiled-path]), :type :var} {:name resolve-arg-code, :file "com/rpl/specter/impl.cljc", :line 838, :arglists ([o possible-params]), :type :var} {:name resolve-nav-code, :file "com/rpl/specter/impl.cljc", :line 862, :arglists ([o possible-params]), :type :var} {:name rich-nav?, :file "com/rpl/specter/impl.cljc", :line 145, :arglists ([n]), :type :var} {:name set-cell!, :file "com/rpl/specter/impl.cljc", :line 257, :arglists ([cell val]), :type :var} {:name smart-str, :file "com/rpl/specter/impl.cljc", :line 35, :arglists ([& elems]), :type :var} {:name SpecialFormUse, :file "com/rpl/specter/impl.cljc", :line 447, :type :var} {:name spy, :file "com/rpl/specter/impl.cljc", :line 25, :arglists ([e]), :type :var} {:name srange-transform*, :file "com/rpl/specter/impl.cljc", :line 546, :arglists ([structure start end next-fn]), :type :var} {:name static-combine, :file "com/rpl/specter/impl.cljc", :line 740, :arglists ([o] [o nav-pos?]), :type :var} {:name static-fn-code, :file "com/rpl/specter/impl.cljc", :line 797, :arglists ([afn args]), :type :var} {:name static-path?, :file "com/rpl/specter/impl.cljc", :line 466, :arglists ([path]), :type :var} {:name static-val-code, :file "com/rpl/specter/impl.cljc", :line 826, :arglists ([o]), :type :var} {:name StaticParam, :file "com/rpl/specter/impl.cljc", :line 784, :type :var} {:name STAY*, :file "com/rpl/specter/impl.cljc", :line 190, :type :var} {:name terminal*, :file "com/rpl/specter/impl.cljc", :line 418, :arglists ([afn vals structure]), :type :var} {:name throw*, :file "com/rpl/specter/impl.cljc", :line 54, :arglists ([etype & args]), :type :macro} {:name throw-illegal, :file "com/rpl/specter/impl.cljc", :line 59, :arglists ([& args]), :type :macro} {:name throw-illegal*, :file "com/rpl/specter/impl.cljc", :line 67, :arglists ([& args]), :type :var} {:name update-cell!, :file "com/rpl/specter/impl.cljc", :line 274, :arglists ([cell afn]), :type :var} {:name used-locals, :file "com/rpl/specter/impl.cljc", :line 892, :arglists ([locals-set form]), :type :var} {:name VarUse, :file "com/rpl/specter/impl.cljc", :line 444, :type :var} {:name walk-select, :file "com/rpl/specter/impl.cljc", :line 598, :arglists ([pred continue-fn structure]), :type :var} {:name walk-until, :file "com/rpl/specter/impl.cljc", :line 612, :arglists ([pred on-match-fn structure]), :type :var})} {:name com.rpl.specter.navs, :publics ({:name AddExtremes, :file "com/rpl/specter/navs.cljc", :line 420, :type :protocol, :members ({:name append-all, :arglists ([structure elements]), :type :var} {:name append-one, :arglists ([structure elem]), :type :var} {:name prepend-all, :arglists ([structure elements]), :type :var} {:name prepend-one, :arglists ([structure elem]), :type :var})} {:name all-select, :file "com/rpl/specter/navs.cljc", :line 25, :arglists ([structure next-fn]), :type :var} {:name AllTransformProtocol, :file "com/rpl/specter/navs.cljc", :line 39, :type :protocol, :members ({:name all-transform, :arglists ([structure next-fn]), :type :var})} {:name extract-basic-filter-fn, :file "com/rpl/specter/navs.cljc", :line 385, :arglists ([path]), :type :var} {:name FastEmpty, :file "com/rpl/specter/navs.cljc", :line 474, :type :protocol, :members ({:name fast-empty?, :arglists ([s]), :type :var})} {:name GetExtremes, :file "com/rpl/specter/navs.cljc", :line 470, :type :protocol, :members ({:name get-first, :arglists ([s]), :type :var} {:name get-last, :arglists ([s]), :type :var})} {:name if-select, :file "com/rpl/specter/navs.cljc", :line 401, :arglists ([vals structure next-fn then-tester then-nav else-nav]), :type :var} {:name if-transform, :file "com/rpl/specter/navs.cljc", :line 410, :arglists ([vals structure next-fn then-tester then-nav else-nav]), :type :var} {:name invoke-end-fn, :file "com/rpl/specter/navs.cljc", :line 689, :arglists ([end-fn structure start]), :type :var} {:name keypath*, :file "com/rpl/specter/navs.cljc", :line 637, :doc "Navigates to the specified key, navigating to nil if it does not exist.\nSetting the value to NONE will remove it from the collection.", :type :var} {:name map-keys-non-transient-transform, :file "com/rpl/specter/navs.cljc", :line 239, :arglists ([structure empty-map next-fn]), :type :var} {:name map-vals-non-transient-transform, :file "com/rpl/specter/navs.cljc", :line 229, :arglists ([structure empty-map next-fn]), :type :var} {:name MapTransformProtocol, :file "com/rpl/specter/navs.cljc", :line 222, :type :protocol, :members ({:name map-keys-transform, :arglists ([structure next-fn]), :type :var} {:name map-vals-transform, :arglists ([structure next-fn]), :type :var})} {:name must*, :file "com/rpl/specter/navs.cljc", :line 649, :doc "Navigates to the key only if it exists in the map. Setting the value to NONE\nwill remove it from the collection.", :type :var} {:name not-NONE?, :file "com/rpl/specter/navs.cljc", :line 56, :arglists ([v]), :type :var} {:name not-selected?*, :file "com/rpl/specter/navs.cljc", :line 14, :arglists ([compiled-path vals structure]), :type :var} {:name nthpath*, :file "com/rpl/specter/navs.cljc", :line 663, :type :var} {:name PosNavigator, :file "com/rpl/specter/navs.cljc", :line 477, :type :var} {:name queue?, :file "com/rpl/specter/navs.cljc", :line 35, :arglists ([coll]), :type :var} {:name selected?*, :file "com/rpl/specter/navs.cljc", :line 20, :arglists ([compiled-path vals structure]), :type :var} {:name srange-select, :file "com/rpl/specter/navs.cljc", :line 375, :arglists ([structure start end next-fn]), :type :var} {:name srange-transform, :file "com/rpl/specter/navs.cljc", :line 382, :type :var} {:name SrangeEndFunction, :file "com/rpl/specter/navs.cljc", :line 686, :type :var} {:name transient-vec-count, :file "com/rpl/specter/navs.cljc", :line 518, :arglists ([v]), :type :var} {:name UpdateExtremes, :file "com/rpl/specter/navs.cljc", :line 466, :type :protocol, :members ({:name update-first, :arglists ([s afn]), :type :var} {:name update-last, :arglists ([s afn]), :type :var})} {:name vec-count, :file "com/rpl/specter/navs.cljc", :line 508, :arglists ([v]), :type :var} {:name void-transformed-kv-pair?, :file "com/rpl/specter/navs.cljc", :line 42, :arglists ([newkv]), :type :var})} {:name com.rpl.specter.protocols, :publics ({:name Collector, :file "com/rpl/specter/protocols.cljc", :line 21, :doc "Do not use this protocol directly. All navigators must be created using\nmacros in com.rpl.specter namespace.", :type :protocol, :members ({:name collect-val, :arglists ([this structure]), :type :var})} {:name ImplicitNav, :file "com/rpl/specter/protocols.cljc", :line 26, :type :protocol, :members ({:name implicit-nav, :arglists ([obj]), :type :var})} {:name RichNavigator, :file "com/rpl/specter/protocols.cljc", :line 3, :doc "Do not use this protocol directly. All navigators must be created using macros\nin com.rpl.specter namespace.", :type :protocol, :members ({:name select*, :arglists ([this vals structure next-fn]), :doc "An implementation of `select*` must call `next-fn` on each\nsubvalue of `structure`. The result of `select*` is specified\nas follows:\n\n1. `NONE` if `next-fn` never called\n2. `NONE` if all calls to `next-fn` return `NONE`\n3. Otherwise, any non-`NONE` return value from calling `next-fn`\n", :type :var} {:name transform*, :arglists ([this vals structure next-fn]), :doc "An implementation of `transform*` must use `next-fn` to transform\nany subvalues of `structure` and then merge those transformed values\nback into `structure`. Everything else in `structure` must be unchanged.", :type :var})})} {:name com.rpl.specter.transients, :publics ({:name END!, :file "com/rpl/specter/transients.cljc", :line 24, :doc "Navigates to an empty (persistent) vector at the end of a transient vector.\n", :type :var} {:name FIRST!, :file "com/rpl/specter/transients.cljc", :line 52, :doc "Navigates to the first element of a transient vector.\n", :type :var} {:name keypath!, :file "com/rpl/specter/transients.cljc", :line 12, :doc "Navigates to the specified key of a transient collection,\nnavigating to nil if it doesn't exist.", :type :var} {:name LAST!, :file "com/rpl/specter/transients.cljc", :line 56, :doc "Navigates to the last element of a transient vector.\n", :type :var} {:name submap!, :file "com/rpl/specter/transients.cljc", :line 85, :doc "Navigates to the specified persistent submap of a transient map.\n", :type :var})} {:name com.rpl.specter.zipper, :publics ({:name DOWN, :file "com/rpl/specter/zipper.cljc", :line 58, :type :var} {:name find-first, :file "com/rpl/specter/zipper.cljc", :line 120, :doc "Navigate the zipper to the first element\nin the structure matching predfn. A linear scan\nis done using NEXT to find the element.", :type :var} {:name INNER-LEFT, :file "com/rpl/specter/zipper.cljc", :line 89, :doc "Navigate to the empty subsequence directly to the\nleft of this element.", :type :var} {:name INNER-RIGHT, :file "com/rpl/specter/zipper.cljc", :line 80, :doc "Navigate to the empty subsequence directly to the\nright of this element.", :type :var} {:name LEFT, :file "com/rpl/specter/zipper.cljc", :line 54, :doc "Navigate to the element to the left.\nIf no element there, works like STOP.", :type :var} {:name LEFTMOST, :file "com/rpl/specter/zipper.cljc", :line 66, :type :var} {:name NEXT, :file "com/rpl/specter/zipper.cljc", :line 24, :doc "Navigate to the next element in the structure.\nIf no next element, works like STOP.", :type :var} {:name NEXT-WALK, :file "com/rpl/specter/zipper.cljc", :line 131, :doc "Navigate to every element reachable using calls\nto NEXT", :type :var} {:name NODE, :file "com/rpl/specter/zipper.cljc", :line 98, :type :var} {:name NODE-SEQ, :file "com/rpl/specter/zipper.cljc", :line 106, :doc "Navigate to the subsequence containing only\nthe node currently pointed to. This works just\nlike srange and can be used to remove elements\nfrom the structure", :type :var} {:name PREV, :file "com/rpl/specter/zipper.cljc", :line 61, :doc "Navigate to the previous element.\nIf this is the first element, works like STOP.", :type :var} {:name RIGHT, :file "com/rpl/specter/zipper.cljc", :line 50, :doc "Navigate to the element to the right.\nIf no element there, works like STOP.", :type :var} {:name RIGHTMOST, :file "com/rpl/specter/zipper.cljc", :line 65, :type :var} {:name SEQ-ZIP, :file "com/rpl/specter/zipper.cljc", :line 20, :type :var} {:name UP, :file "com/rpl/specter/zipper.cljc", :line 59, :type :var} {:name VECTOR-ZIP, :file "com/rpl/specter/zipper.cljc", :line 19, :type :var} {:name XML-ZIP, :file "com/rpl/specter/zipper.cljc", :line 21, :type :var} {:name zipper, :file "com/rpl/specter/zipper.cljc", :line 12, :type :var})})}, :pom-str "<?xml version=\"1.0\" encoding=\"UTF-8\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>com.rpl</groupId>\n  <artifactId>specter</artifactId>\n  <packaging>jar</packaging>\n  <version>1.1.3</version>\n  <name>specter</name>\n  <description/>\n  <scm>\n    <url>https://github.com/redplanetlabs/specter</url>\n    <connection>scm:git:git://github.com/redplanetlabs/specter.git</connection>\n    <developerConnection>scm:git:ssh://git@github.com/redplanetlabs/specter.git</developerConnection>\n    <tag>28ef42152a74a99caaa60907516fc0f519b4731b</tag>\n  </scm>\n  <build>\n    <sourceDirectory>src/clj</sourceDirectory>\n    <testSourceDirectory>test</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>resources</directory>\n      </testResource>\n    </testResources>\n    <directory>target</directory>\n    <outputDirectory>target/classes</outputDirectory>\n    <plugins>\n      <plugin>\n        <groupId>org.codehaus.mojo</groupId>\n        <artifactId>build-helper-maven-plugin</artifactId>\n        <version>1.7</version>\n        <executions>\n          <execution>\n            <id>add-source</id>\n            <phase>generate-sources</phase>\n            <goals>\n              <goal>add-source</goal>\n            </goals>\n            <configuration>\n              <sources>\n                <source>src/java</source>\n              </sources>\n            </configuration>\n          </execution>\n          <execution>\n            <id>add-test-source</id>\n            <phase>generate-test-sources</phase>\n            <goals>\n              <goal>add-test-source</goal>\n            </goals>\n            <configuration>\n              <sources>\n                <source>target/test-classes</source>\n              </sources>\n            </configuration>\n          </execution>\n        </executions>\n      </plugin>\n    </plugins>\n  </build>\n  <repositories>\n    <repository>\n      <id>central</id>\n      <url>https://repo1.maven.org/maven2/</url>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n    <repository>\n      <id>clojars</id>\n      <url>https://repo.clojars.org/</url>\n      <snapshots>\n        <enabled>true</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n  </repositories>\n  <dependencyManagement>\n    <dependencies/>\n  </dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>riddley</groupId>\n      <artifactId>riddley</artifactId>\n      <version>0.1.12</version>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>test.check</artifactId>\n      <version>0.9.0</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojure</artifactId>\n      <version>1.7.0</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojurescript</artifactId>\n      <version>1.10.439</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n<!-- This file was autogenerated by Leiningen.\n  Please do not edit it directly; instead edit project.clj and regenerate it.\n  It should not be considered canonical data. For more information see\n  https://github.com/technomancy/leiningen -->\n"}