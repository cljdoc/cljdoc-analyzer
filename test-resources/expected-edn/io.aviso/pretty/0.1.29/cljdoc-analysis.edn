{:group-id "io.aviso", :artifact-id "pretty", :version "0.1.29", :analysis {"clj" ({:doc "Help with generating textual output that includes ANSI escape codes for formatting.\n", :name io.aviso.ansi, :publics ({:name black, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as black text.\n", :type :var} {:name black-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as black background text.\n", :type :var} {:name black-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable black background text.\n", :type :var} {:name black-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable black text.\n", :type :var} {:name blue, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as blue text.\n", :type :var} {:name blue-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as blue background text.\n", :type :var} {:name blue-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable blue background text.\n", :type :var} {:name blue-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable blue text.\n", :type :var} {:name bold, :file "io/aviso/ansi.clj", :line 72, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold text.\n", :type :var} {:name bold-black, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold black text.\n", :type :var} {:name bold-black-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold black background text.\n", :type :var} {:name bold-black-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold black background text.\n", :type :var} {:name bold-black-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold black text.\n", :type :var} {:name bold-blue, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold blue text.\n", :type :var} {:name bold-blue-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold blue background text.\n", :type :var} {:name bold-blue-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold blue background text.\n", :type :var} {:name bold-blue-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold blue text.\n", :type :var} {:name bold-cyan, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold cyan text.\n", :type :var} {:name bold-cyan-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold cyan background text.\n", :type :var} {:name bold-cyan-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold cyan background text.\n", :type :var} {:name bold-cyan-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold cyan text.\n", :type :var} {:name bold-font, :file "io/aviso/ansi.clj", :line 72, :doc "Constant for ANSI code to enable bold text.\n", :type :var} {:name bold-green, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold green text.\n", :type :var} {:name bold-green-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold green background text.\n", :type :var} {:name bold-green-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold green background text.\n", :type :var} {:name bold-green-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold green text.\n", :type :var} {:name bold-magenta, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold magenta text.\n", :type :var} {:name bold-magenta-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold magenta background text.\n", :type :var} {:name bold-magenta-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold magenta background text.\n", :type :var} {:name bold-magenta-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold magenta text.\n", :type :var} {:name bold-red, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold red text.\n", :type :var} {:name bold-red-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold red background text.\n", :type :var} {:name bold-red-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold red background text.\n", :type :var} {:name bold-red-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold red text.\n", :type :var} {:name bold-white, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold white text.\n", :type :var} {:name bold-white-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold white background text.\n", :type :var} {:name bold-white-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold white background text.\n", :type :var} {:name bold-white-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold white text.\n", :type :var} {:name bold-yellow, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold yellow text.\n", :type :var} {:name bold-yellow-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as bold yellow background text.\n", :type :var} {:name bold-yellow-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold yellow background text.\n", :type :var} {:name bold-yellow-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable bold yellow text.\n", :type :var} {:name csi, :file "io/aviso/ansi.clj", :line 8, :doc "The control sequence initiator: `ESC [`\n", :type :var} {:name cyan, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as cyan text.\n", :type :var} {:name cyan-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as cyan background text.\n", :type :var} {:name cyan-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable cyan background text.\n", :type :var} {:name cyan-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable cyan text.\n", :type :var} {:name green, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as green text.\n", :type :var} {:name green-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as green background text.\n", :type :var} {:name green-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable green background text.\n", :type :var} {:name green-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable green text.\n", :type :var} {:name inverse, :file "io/aviso/ansi.clj", :line 72, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as inverse text.\n", :type :var} {:name inverse-font, :file "io/aviso/ansi.clj", :line 72, :doc "Constant for ANSI code to enable inverse text.\n", :type :var} {:name italic, :file "io/aviso/ansi.clj", :line 72, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as italic text.\n", :type :var} {:name italic-font, :file "io/aviso/ansi.clj", :line 72, :doc "Constant for ANSI code to enable italic text.\n", :type :var} {:name magenta, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as magenta text.\n", :type :var} {:name magenta-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as magenta background text.\n", :type :var} {:name magenta-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable magenta background text.\n", :type :var} {:name magenta-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable magenta text.\n", :type :var} {:name red, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as red text.\n", :type :var} {:name red-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as red background text.\n", :type :var} {:name red-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable red background text.\n", :type :var} {:name red-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable red text.\n", :type :var} {:name reset-font, :file "io/aviso/ansi.clj", :line 17, :doc "Resets the font, clearing bold, italic, color, and background color.\n", :type :var} {:name sgr, :file "io/aviso/ansi.clj", :line 13, :doc "The Select Graphic Rendition suffix: m\n", :type :var} {:name strip-ansi, :file "io/aviso/ansi.clj", :line 80, :arglists ([string]), :doc "Removes ANSI codes from a string, returning just the raw text.\n", :type :var} {:name visual-length, :file "io/aviso/ansi.clj", :line 85, :arglists ([string]), :doc "Returns the length of the string, with ANSI codes stripped out.\n", :type :var} {:name white, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as white text.\n", :type :var} {:name white-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as white background text.\n", :type :var} {:name white-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable white background text.\n", :type :var} {:name white-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable white text.\n", :type :var} {:name yellow, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as yellow text.\n", :type :var} {:name yellow-bg, :file "io/aviso/ansi.clj", :line 57, :arglists ([text]), :doc "Wraps the provided text with ANSI codes to render as yellow background text.\n", :type :var} {:name yellow-bg-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable yellow background text.\n", :type :var} {:name yellow-font, :file "io/aviso/ansi.clj", :line 57, :doc "Constant for ANSI code to enable yellow text.\n", :type :var})} {:doc "Utilities for formatting binary data (byte arrays) or binary deltas.\n", :name io.aviso.binary, :publics ({:name BinaryData, :file "io/aviso/binary.clj", :line 8, :doc "Allows various data sources to be treated as a byte-array data type that\nsupports a length and random access to individual bytes.\n\nBinaryData is extended onto byte arrays, onto `String`, and onto nil.", :type :protocol, :members ({:name byte-at, :arglists ([this index]), :doc "The byte value at a specific offset.\n", :type :var} {:name data-length, :arglists ([this]), :doc "The total number of bytes available.\n", :type :var})} {:name format-binary, :file "io/aviso/binary.clj", :line 123, :arglists ([data] [data options]), :doc "Formats the data using [[write-binary]] and returns the result as a string.\n", :type :var} {:name format-binary-delta, :file "io/aviso/binary.clj", :line 185, :arglists ([expected actual]), :doc "Formats the delta using [[write-binary-delta]] and returns the result as a string.\n", :type :var} {:name write-binary, :file "io/aviso/binary.clj", :line 78, :arglists ([data] [writer data options]), :doc "Formats a ByteData into a hex-dump string, consisting of multiple lines; each line formatted as:\n\n    0000: 43 68 6F 6F 73 65 20 69 6D 6D 75 74 61 62 69 6C 69 74 79 2C 20 61 6E 64 20 73 65 65 20 77 68 65\n    0020: 72 65 20 74 68 61 74 20 74 61 6B 65 73 20 79 6F 75 2E\n\nThe full version specifies:\n\n- [[StringWriter]] to which to write output\n- [[BinaryData]] to write\n- option keys and values:\n\n    :ascii - boolean\n    : true to enable ASCII mode\n\n    :line-bytes - number\n    : number of bytes per line (defaults to 16 for ASCII, 32 otherwise)\n\nIn ASCII mode, the output is 16 bytes per line, but each line includes the ASCII printable characters:\n\n    0000: 43 68 6F 6F 73 65 20 69 6D 6D 75 74 61 62 69 6C |Choose immutabil|\n    0010: 69 74 79 2C 20 61 6E 64 20 73 65 65 20 77 68 65 |ity, and see whe|\n    0020: 72 65 20 74 68 61 74 20 74 61 6B 65 73 20 79 6F |re that takes yo|\n    0030: 75 2E                                           |u.              |\n\nA placeholder character (a space with magenta background) is used for any non-printable\ncharacter.", :type :var} {:name write-binary-delta, :file "io/aviso/binary.clj", :line 166, :arglists ([expected actual] [writer expected actual]), :doc "Formats a hex dump of the expected data (on the left) and actual data (on the right). Bytes\nthat do not match are highlighted in green on the expected side, and red on the actual side.\nWhen one side is shorter than the other, it is padded with `--` placeholders to make this\nmore clearly visible.\n\nexpected and actual are [[BinaryData]].\n\nDisplay 16 bytes (from each data set) per line.", :type :var})} {:doc "Assistance for formatting data into columns. Each column has a width, and data within the column\nmay be left or right justified. Generally, columns are sized to the largest item in the column.\nWhen a value is provided in a column, it may be associated with an explicit width which is helpful\nwhen the value contains non-printing characters (such as those defined in the `io.aviso.ansi` namespace).", :name io.aviso.columns, :publics ({:name format-columns, :file "io/aviso/columns.clj", :line 85, :arglists ([& column-defs]), :doc "Converts a number of column definitions into a formatting function. Each column definition may be:\n\n- a string, to indicate a non-consuming column that outputs a fixed value. This is often just a space\ncharacter or two, to seperate columns.\n- a number, to indicate a consuming column that outputs a left justified value of the given width.\n- a vector containing a keyword and a number; the number is the width, the keyword is the justification.\n- :none, to indicate a consuming column with no explicit width\n- nil, which is treated like an empty string\n\nWith explicit justification, the keyword may be :left, :right, or :none.\n\n:left\n: Pads the column with spaces after the value. Truncates long values from the right, displaying\n  initial character and discarding trailing characters.\n\n:right\n: Pads the column with spaces before the value. Truncates long values from the left.\n\n:none\n: Does not pad with spaces at all, and should only be used in the final column.\n\nGenerally speaking, truncation does not occur because columns are sized to fit their contents.\n\nA column width is required for `:left` or `:right`. Column width is optional and ignored for `:none`.\n\nValues are normally string, but any type is accepted and will be converted to a string.\nThis code is aware of ANSI codes and ignores them to calculate the length of a value for formatting and\nidentation purposes.\n\nThere will likely be problems if a long string with ANSI codes is truncated, however.\n\nThe returned function accepts a [[StringWriter]] and the column values and writes each column value, with appropriate\npadding, to the [[StringWriter]].\n\nExample:\n\n    (let [formatter (format-columns [:right 20] \": \" [:right 20] \": \" :none)]\n      (write-rows *out* formatter [:last-name :first-name :age] customers))\n", :type :var} {:name max-length, :file "io/aviso/columns.clj", :line 137, :arglists ([coll]), :doc "Find the maximum length of the strings in the collection, based on their visual length (that is,\nomitting ANSI escape codes).", :type :var} {:name max-value-length, :file "io/aviso/columns.clj", :line 145, :arglists ([coll key]), :doc "A convinience for computing the maximum length of one string property from a collection of values.\n\ncoll\n: collection of values\n\nkey\n: key that is passed one value and returns the property, typically a keyword when the values are maps", :type :var} {:name write-rows, :file "io/aviso/columns.clj", :line 201, :arglists ([writer column-formatter extractors row-data] [writer extended-columns-defs row-data]), :doc "A convienience for writing rows of columns using a prepared column formatter.\n\n\nIn the 3-arity version of the function, the extended-column-defs is used to\nautomatically compute the column-formatter and extractors.\n\nExtended column definitions are like the column definitions used with\n[[format-columns]] except:\n\n- The first value in each vector is the extractor (a function or keyword)\n- If the column layout is :left or :right, then the width of the column is computed\n  as the [[max-value-length]] of that column (using the extractor and the row-data).\n- An extended column definition may not be a vector, but instead:\n    - A string, which is treated as literal text\n    - nil, which is ignored\n    - otherwise, assumed to be an extractor whose values will be right justified\n\nwriter\n: [[StringWriter]] target of output\n\nextended-column-defs\n: used to compute column-formatter and extractors taking into account row-data\n\ncolumn-formatter\n: formatter function created by format-columns\n\nextractors\n: seq of functions that extract a column value from a row; typically a keyword when the row is a map\n\nrow-data\n: a seq of row data\n\nExample:\n\n    (write-rows *out*\n                [:last-name \", \" :first-name \": \" [:age :none]]\n                customers)\n\nThis will write three columns, seperated by literal text.\nThe first column will be right justified, and as wide as longest last name.\nThe second column will also be right justified, and as wide as the longest first name.\nThe final column will not be justified at all, so it will be varying width.", :type :var})} {:doc "Format and present exceptions in a pretty (structured, formatted) way.\n", :name io.aviso.exception, :publics ({:name *default-frame-filter*, :file "io/aviso/exception.clj", :line 133, :arglists ([frame]), :doc "Default stack frame filter used when printing REPL exceptions. This will omit frames in the `clojure.lang`\nand `java.lang.reflect` package, hide frames in the `sun.reflect` package,\nand terminates the stack trace at the read-eval-print loop frame.", :dynamic true, :added "0.1.16", :type :var} {:name *default-frame-rules*, :file "io/aviso/exception.clj", :line 93, :doc "The set of rules that forms the basis for [[*default-frame-filter*]], as a vector or vectors.\n\nEach rule is three values:\n\n* A function that extracts the value from the stack frame map (typically, this is a keyword such\nas :package or :name). The value is converted to a string.\n\n* A string or regexp used for matching.\n\n* A resulting frame visibility (:hide, :omit, :terminate, or :show).\n\nThe default rules:\n\n* omit everything in clojure.lang and java.lang.reflect.\n* hide everything in sun.reflect\n* terminate at speclj.* or clojure.main/repl/read-eval-print\n", :dynamic true, :added "0.1.18", :type :var} {:name *fonts*, :file "io/aviso/exception.clj", :line 15, :doc "ANSI fonts for different elements in the formatted exception report.\n", :dynamic true, :type :var} {:name *traditional*, :file "io/aviso/exception.clj", :line 27, :doc "If bound to true, then exceptions will be formatted the traditional way (the only option prior to 0.1.15).\n", :dynamic true, :added "0.1.15", :type :var} {:name analyze-exception, :file "io/aviso/exception.clj", :line 402, :arglists ([e options]), :doc "Converts an exception into a seq of maps representing nested exceptions.\nThe order reflects exception nesting; first exception is the most recently\nthrown, last is the deepest, or root, exception ... the initial exception\nthrown in a chain of nested exceptions.\n\nThe options map is as defined by [[write-exception]].\n\nEach exception map contains:\n\n:class-name String\n: name of the Java class for the exception\n\n:message String\n: value of the exception's message property (possibly nil)\n\n:properties Map\n: map of properties to (optionally) present in the exception report\n\n:stack-trace Vector\n: stack trace element maps, or nil.\n  Only present in the root exception.\n\nThe :properties map does not include any properties that are assignable to type Throwable.\n\nThe first property that is assignable to type Throwable (not necessarily the rootCause property)\nwill be used as the nested exception (for the next map in the sequence).", :type :var} {:name demangle, :file "io/aviso/exception.clj", :line 70, :arglists ([s]), :doc "De-mangle a Java name back to a Clojure name by converting mangled sequences, such as \"_QMARK_\"\nback into simple characters.", :type :var} {:name exception-dispatch, :file "io/aviso/exception.clj", :line 459, :doc "The pretty print dispatch function used when formatting exception output (specifically, when\nprinting the properties of an exception). Normally, this is the same as the simple-dispatch\n(in clojure.pprint) but can be extended for specific cases:\n\n    (import com.stuartsierra.component.SystemMap)\n\n    (defmethod exception-dispatch SystemMap [system-map] (print \"#<SystemMap>\"))\n\nThis ensures that the SystemMap record, wherever it appears in the exception output,\nis represented as the string `#<SystemMap>`; normally it would print as a deeply nested\nset of maps.\n\nThis same approach can be adapted to any class or type whose structure is problematic\nfor presenting in the exception output, whether for size and complexity reasons, or due to\nsecurity concerns.", :type :multimethod} {:name expand-stack-trace, :file "io/aviso/exception.clj", :line 285, :arglists ([exception]), :doc "Extracts the stack trace for an exception and returns a seq of expanded stack frame maps:\n\n:file String\n: file name\n\n:line Integer\n: line number as an integer, or nil\n\n:class String\n: fully qualified Java class name\n\n:package String\n: Java package name, or nil for root package\n\n:simple-class String\n: simple name of Java class (without package prefix)\n\n:method String\n: Java method name\n\n:is-clojure?\n: true if this represents a Clojure function call, rather than a Java\n  method invocation.\n\n:name String\n: Fully qualified Clojure name (demangled from the Java class name), or the empty string for non-Clojure stack frames\n\n:names seq of String\n: Clojure name split at slashes (empty for non-Clojure stack frames)", :type :var} {:name format-exception, :file "io/aviso/exception.clj", :line 616, :arglists ([exception] [exception options]), :doc "Formats an exception as a multi-line string using [[write-exception]].\n", :type :var} {:name parse-exception, :file "io/aviso/exception.clj", :line 668, :arglists ([exception-text options]), :doc "Given a chunk of text for an exception report (as with `.printStackTrace`), attempts to\npiece together the same information provided by [[analyze-exception]].  The result\nis ready to pass to [[write-exception*]].\n\nThis code does not attempt to recreate properties associated with the exceptions; in most\nexception's cases, this is not necessarily written to the output. For clojure.lang.ExceptionInfo,\nit is hard to distinguish the message text from the printed exception map.\n\nThe options are used when processing the stack trace and may include the :filter and :frame-limit keys.\n\nReturns a sequence of exception maps; the final map will include the :stack-trace key (a vector\nof stack trace element maps).  The exception maps are ordered outermost to innermost (that final map\nis the root exception).\n\nThis should be considered experimental code; there are many cases where it may not work properly.\n\nIt will work quite poorly with exceptions whose message incorporates a nested exception's\n.printStackTrace output. This happens too often with JDBC exceptions, for example.", :added "0.1.21", :type :var} {:name write-exception, :file "io/aviso/exception.clj", :line 549, :arglists ([exception] [writer exception] [writer exception options]), :doc "Writes a formatted version of the exception to the [[StringWriter]]. By default, writes to *out* and includes\nthe stack trace, with no frame limit.\n\nThe options map may have the following keys:\n\n:filter\n: The stack frame filter, which defaults to [[*default-stack-frame-filter*]].\n\n:properties\n: If true (the default) then properties of exceptions will be output.\n\n:frame-limit\n: If non-nil, the number of stack frames to keep when outputing the stack trace\n  of the deepest exception.\n\nOutput may be traditional or modern, as controlled by [[*traditional*]].\nTraditional is the typical output order for Java: the stack of exceptions comes first (outermost to\ninnermost) followed by the stack trace of the innermost exception, with the frames\nin deepest to shallowest order.\n\nModern output is more readable; the stack trace comes first and is reversed: shallowest frame to deepest.\nThen the exception stack is output, from the root exception to the outermost exception.\nThe modern output order is more readable, as it puts the most useful information together at the bottom, so that\nit is not necessary to scroll back to see, for example, where the exception occured.\n\nThe default is modern.\n\nThe stack frame filter is passed the map detailing each stack frame\nin the stack trace, must return one of the following values:\n\n:show\n: is the normal state; display the stack frame.\n\n:hide\n: prevents the frame from being displayed, as if it never existed.\n\n:omit\n: replaces the frame with a \"...\" placeholder; multiple consecutive :omits will be collapsed to a single line.\n  Use :omit for \"uninteresting\" stack frames.\n\n:terminate\n: hides the frame AND all later frames.\n\nThe default filter is [[*default-frame-filter*]].  An explicit filter of nil will display all stack frames.\n\nRepeating lines are collapsed to a single line, with a repeat count. Typically, this is the result of\nan endless loop that terminates with a StackOverflowException.\n\nWhen set, the frame limit is the number of stack frames to display; if non-nil, then some of the outermost\nstack frames may be omitted. It may be set to 0 to omit the stack trace entirely (but still display\nthe exception stack).  The frame limit is applied after the frame filter (which may hide or omit frames) and\nafter repeating stack frames have been identified and coallesced ... :frame-limit is really the number\nof _output_ lines to present.\n\nProperties of exceptions will be output using Clojure's pretty-printer, honoring all of the normal vars used\nto configure pretty-printing; however, if `*print-length*` is left as its default (nil), the print length will be set to 10.\nThis is to ensure that infinite lists do not cause endless output or other exceptions.\n\nThe `*fonts*` var contains ANSI definitions for how fonts are displayed; bind it to nil to remove ANSI formatting entirely.", :type :var} {:name write-exception*, :file "io/aviso/exception.clj", :line 496, :arglists ([writer exception-stack options]), :doc "Contains the main logic for [[write-exception]], which simply expands\nthe exception (via [[analyze-exception]]) before invoking this function.\n\nThe writer is locked for the duration of the function, and `*flush-on-newline*` is\nbound to false. This helps keep output from multiple threads from interleaving in\na quite unreadable way.\n\nThis code was extracted so as to support [[parse-exception]].", :added "0.1.21", :type :var})} {:doc "Provides functions that hook into clojure.tools.logging to make use of Pretty to format exceptions.\n\nYou must [add clojure.tools.logging as an explicit dependency](https://github.com/clojure/tools.logging) of your project.", :added "0.1.15", :name io.aviso.logging, :publics ({:name install-pretty-logging, :file "io/aviso/logging.clj", :line 11, :arglists ([] [frame-filter-fn]), :doc "Modifies clojure.tools.logging to use pretty exception logging.\n", :type :var} {:name install-uncaught-exception-handler, :file "io/aviso/logging.clj", :line 48, :arglists ([]), :doc "Installs a default UncaughtExceptionHandler. \n", :type :var} {:name uncaught-exception-handler, :file "io/aviso/logging.clj", :line 40, :arglists ([]), :doc "Creates a reified UncaughtExceptionHandler that uses clojure.tools.logging/error, rather than\nsimplying printing the exception, which is the default behavior.", :type :var})} {:doc "Utilities to assist with REPL-oriented development\n", :name io.aviso.repl, :publics ({:name install-pretty-exceptions, :file "io/aviso/repl.clj", :line 48, :arglists ([]), :doc "Installs an override that outputs pretty exceptions when caught by the main REPL loop. Also, overrides\n`clojure.repl/pst`, `clojure.stacktrace/print-stack-trace`, `clojure.stacktrace/print-cause-trace`.\n\nIn addition, installs a [[uncaught-exception-handler]] so that uncaught exceptions in non-REPL threads\nwill be printed reasonably. See [[io.aviso.logging]] for a better handler, used when clojure.tools.logging\nis available.\n\nCaught exceptions do not print the stack trace; the pst replacement does.", :type :var} {:name pretty-print-stack-trace, :file "io/aviso/repl.clj", :line 41, :arglists ([tr] [tr n]), :doc "Replacement for `clojure.stracktrace/print-stack-trace` and `print-cause-trace`. These functions are used by `clojure.test`.\n", :type :var} {:name pretty-pst, :file "io/aviso/repl.clj", :line 35, :arglists ([] [e]), :doc "Used as an override of `clojure.repl/pst` but uses pretty formatting. The optional parameter must be an exception\n(it can not be a depth, as with the standard implementation of `pst`).", :type :var} {:name pretty-repl-caught, :file "io/aviso/repl.clj", :line 19, :arglists ([e]), :doc "A replacement for `clojure.main/repl-caught` that prints the exception to `*err*`, without a stack trace or properties.\n", :type :var} {:name uncaught-exception-handler, :file "io/aviso/repl.clj", :line 24, :arglists ([]), :doc "Creates a reified UncaughtExceptionHandler that prints the formatted exception to `*err*`.\n", :added "0.1.18", :type :var})} {:doc "The StringWriter protocol is used as the target of any written output.\n", :name io.aviso.writer, :publics ({:name eol, :file "io/aviso/writer.clj", :line 24, :doc "End-of-line terminator, platform specific.\n", :type :var} {:name into-string, :file "io/aviso/writer.clj", :line 54, :arglists ([f & params]), :doc "Creates a `StringBuilder` and passes that as the first parameter to the function, along with the other parameters.\n\nReturns the value of the `StringBuilder` after invoking the function.", :type :var} {:name StringWriter, :file "io/aviso/writer.clj", :line 6, :doc "May receive strings, which are printed, or stored.\n\n`StringWriter` is extended onto `java.lang.Appendable`, a common interface implemented by both `PrintWriter` and `StringBuilder` (among\nmany others).", :type :protocol, :members ({:name flush-writer, :arglists ([this]), :doc "Flushes output to the `StringWriter`, where supported.\n", :type :var} {:name write-string, :arglists ([this string]), :doc "Writes the string to the `StringWriter`.\n", :type :var})} {:name write, :file "io/aviso/writer.clj", :line 28, :arglists ([writer value] [writer value & values]), :doc "Constructs a string from the values (with no seperator) and writes the string to the StringWriter.\n\nThis is used to get around the fact that protocols do not support varadic parameters.", :type :var} {:name writef, :file "io/aviso/writer.clj", :line 49, :arglists ([writer fmt & values]), :doc "Writes formatted data.\n", :type :var} {:name writeln, :file "io/aviso/writer.clj", :line 39, :arglists ([writer] [writer & values]), :doc "Constructs a string from the values (with no seperator) and writes the string to the `StringWriter`,\nfollowed by an end-of-line terminator, then flushes the writer.", :type :var})} {:doc "A plugin for Leiningen that automatically enables pretty printing.\n", :added "0.1.19", :name pretty.plugin, :publics ({:name hooks, :file "pretty/plugin.clj", :line 7, :arglists ([]), :doc "Enables pretty printing of exceptions within Leiningen. This is evaluated in the Leinigen classpath, not the project's\n(if any).", :type :var} {:name middleware, :file "pretty/plugin.clj", :line 16, :arglists ([project]), :doc "Automatically adds the :injections that enable Pretty.\n", :type :var})})}, :pom-str "<?xml version=\"1.0\" encoding=\"UTF-8\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>io.aviso</groupId>\n  <artifactId>pretty</artifactId>\n  <packaging>jar</packaging>\n  <version>0.1.29</version>\n  <name>pretty</name>\n  <description>Clojure library to help print things, prettily</description>\n  <url>https://github.com/AvisoNovate/pretty</url>\n  <licenses>\n    <license>\n      <name>Apache Sofware License 2.0</name>\n      <url>http://www.apache.org/licenses/LICENSE-2.0.html</url>\n    </license>\n  </licenses>\n  <scm>\n    <connection>scm:git:git://github.com/AvisoNovate/pretty.git</connection>\n    <developerConnection>scm:git:ssh://git@github.com/AvisoNovate/pretty.git</developerConnection>\n    <tag>1b65019f90c884289f6ed45729840174acaae7e0\n</tag>\n    <url>https://github.com/AvisoNovate/pretty</url>\n  </scm>\n  <build>\n    <sourceDirectory>src</sourceDirectory>\n    <testSourceDirectory>test</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>resources</directory>\n      </testResource>\n    </testResources>\n    <directory>target</directory>\n    <outputDirectory>target/classes</outputDirectory>\n    <plugins/>\n  </build>\n  <repositories>\n    <repository>\n      <id>central</id>\n      <url>https://repo1.maven.org/maven2/</url>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n    <repository>\n      <id>clojars</id>\n      <url>https://clojars.org/repo/</url>\n      <snapshots>\n        <enabled>true</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n  </repositories>\n  <dependencies>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojure</artifactId>\n      <version>1.5.0</version>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>tools.logging</artifactId>\n      <version>0.3.1</version>\n      <optional>true</optional>\n    </dependency>\n    <dependency>\n      <groupId>criterium</groupId>\n      <artifactId>criterium</artifactId>\n      <version>0.4.4</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n<!-- This file was autogenerated by Leiningen.\n  Please do not edit it directly; instead edit project.clj and regenerate it.\n  It should not be considered canonical data. For more information see\n  https://github.com/technomancy/leiningen -->\n"}